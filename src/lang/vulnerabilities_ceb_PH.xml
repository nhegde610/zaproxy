<?xml version="1.0" encoding="utf-8" ?>
<vulnerabilities xmlns="http://tempuri.org/XMLSchemaOptions.xsd">

<vuln_items>wasc_1</vuln_items>
<vuln_item_wasc_1>
	<alert>Dili igo nga pagpamatuod</alert>
	<desc>Ang igo nga pagpamatuod nga mahitabo samtang ang usa ka web site gatugot sa usa ka attacker na maka-access ug mga maliputung butang o mga kalihukan baskin walay maayong pamatuod. Ang mga web-based na mga himan para sa pagdumala kay usa na maayong panag-ingnan sa mga web site nga gahatag ug access sa sensitibo na kalihukan. Depende sa espesipikong nga online nga kapanguhaan, kining nga mga web aplikasyon na dili direkta nga makasulod na walay kinahanglan sa tiggamit aron sutaon pag-ayo sa ila nga pagkatawo.

Para paglibot sa pag-establisar sa pagpamatuod, pipila ka mga kapanguhaan kay protektado pinaagi sa "nagtago" ang piho nga lokasyon ug dili ang sumpay na lokasyon ngadto sa nag-unang web site o uban na publikong mga lugar. Bisan pa niana, kini nga paagi kay wala nay lain kay sa "Kasiguraduhan Gikan sa Ngitngit". Kini kay importante nga masabtan nga bisan ang usa ka tinubdan wala mahibal-an sa usa ka tig-atake, kini gihapon nga mapabilin nga diretso nga direktang pinaagi sa usa ka piho nga URL. Ang piho nga URL mahimong modiskobrehan pinaagi sa Kabangis na pagsulay alang sa kasagaran nga file ug direktoryo nga mga dapit (/ admin alang sa panig-ingnan), mga mensahe sa sayop, mga log sa nagtudlo, o mga dokumentasyon sama sa mga file sa pagtabang. Kini nga mga kapanguhaan, bisan kini nga sulod-sa-kaayohan nga gipalihok, kinahanglan nga igong mapanalipdan.</desc>
	<solution>Phase: Arkitektura ug Disenyo
Gamiton ang pagmatood sa framework o ang librarya sama sa OWASP ESAPI Pagmamatood na bahin niini.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authentication</reference>
	<reference>http://cwe.mitre.org/data/definitions/287.html</reference>
	<reference>http://cwe.mitre.org/data/definitions/284.html</reference>
</vuln_item_wasc_1>

<vuln_items>wasc_2</vuln_items>
<vuln_item_wasc_2>
	<alert>Dili igo ang pagmamatood</alert>
	<desc>Dili igo ang agmatood sa mga resulta na kanus ang aplikasyon na dili mo himo ug igo magpamatood na tan-awon para sigurohon na ang mogamit sa paghimo ug usa ka gamit o pagsulod sa datos sa usa ka paagi na makanunayon uban ang seguridad sa palisiya. Ang pagmatood na mga pamaaging kinahanglan nga ipatuman kung unsa ang gitugot sa usa ka tiggamit, serbisyo o aplikasyon. Sa dihang usa ka tiggamit kay gipamatud-an sa usa ka web site, wala kini magpasabot nga ang tiggamit kinahanglan nga adunay bug-os nga pag-access sa tanan nga sulod ug gamit.

Dili igo na Katungdanan na Pagmatood.

Daghang mga aplikasyon naghatag og nagkalainlaing aplikasyon sa paggamit sa lain-laing mga tiggamit. Usa ka balita na lugar na magatugot sa mga tiggamit sa pagtan-aw sa mga istorya, apan dili pagmantala niini. Usa ka accounting na sistema adunay lain-laing mga pagtugot alang sa usa ka Clerk Accountable Payable ug Clerk Account Receivable. Dili sakto na katungdanan sa pagmatood na mahitabo sa diha nga ang usa ka aplikasyon dili makapugong sa mga tiggamit sa pag-access sa aplikasyon nga paglapas sa polisiya sa seguridad.

Usa ka makita kaayo na pananglitan kay pagka 2005 nga pagpatik sa proseso sa aplikasyon sa Harvard Business School. Usa ka pagpamatood na kapakyasan na nagtugot sa mga tiggamit sa pagtan-aw sa ilang kaugalingong mga datos kung dili unta sila tugutan nga maka-access sa bahin sa web site.
 
Dili igo na datos sa pagmamatuod

Daghang mga aplikasyon na gibutyag sa nagpahipi nga mga tigpaila sa datos sa usa ka URL. Pananglitan, kon mag-access sa medikal nga rekord sa usa ka sistema na ang usa mahimong adunany usa ka URL sama sa:

http://example.com/RecordView?id=12345

Kung ang aplikasyon kay dili motan-aw sa pagmamatuod sa ID sa tiggamit kay naay katungod sa pagbasa, unya kini mahimong magpakita sa datos ngadto sa tiggamit nga dili makita sa tiggamitay.

Insufficient Data Authorization is more common than Insufficient Function Authorization because programmers generally have complete knowledge of application functionality, but do not always have a complete mapping of all data that the application will access. Programmers often have tight control over function authorization mechanisms, but rely on other systems such as databases to perform data authorization.</desc>
	<solution>Mga hugna: Arkitektura ug Disenyo; Operasyon
Mahimong pag-amping ug maayo sa pagdumala sa pagpahimtang, pagdumala, ug paggunit sa mga pribilehiyo. Tin-aw nga pagdumala sa mga trust zone sa software.

Hugna: Arkitektura ug Disenyo
Siguroduha nga agnay na compartmentalization kay gitukod ngadto sa sistema sa disenyo ug nga ang compartmentalization nagsilbi nga tugotan ug dugang pagpalig-on sa pagpahigayon sa pribilehiyo nga pagbulag. Ang mga arkitekto ug mga tigdesinyo kay kinahanglan nga mosalig sa prinsipyo sa labing gamay nga pribilehiyo sa pagdesisyon kung kini tukma nga gamiton ug aron ihulog ang mga pribilehiyo sa sistema.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authorization</reference>
	<reference>http://cwe.mitre.org/data/definitions/284.html</reference>
	<reference>http://cwe.mitre.org/data/definitions/285.html</reference>
</vuln_item_wasc_2>

<vuln_items>wasc_3</vuln_items>
<vuln_item_wasc_3>
	<alert>Ang Integer nga nag-awas</alert>
	<desc>Ang Integer nga Nag-awas kay mao ang kondisyon nga mahitabo sa diha nga ang resulta sa usa ka operasyon sa aritmetika, sama sa pagpadaghan o pagdungag, molapas sa pinakadako nga gidak-on sa integer type nga gigamit sa pagtipig niini. Sa diha nga ang usa ka pag-awas sa integer ang nahitabo, ang gipasabot nga balor mopatim-aw nga "giputos" ang pinakataas nga bili ug nagsugod pag-usab sa pinakaubos nga bili, susama sa usa ka orasan nga nagrepresentar sa 13:00 pinaagi sa pagtudlo sa 1:00.

Pananglitan, ang usa ka 8-bit nga gipirmahan nga integer sa labing komon nga kompyuter nga mga arkitektura kay naay usa ka pinakataas nga bili sa 127 ug usa ka gamay na bili sa -128. Kon ang usa ka programmer nga mga tindahan na ang bili kay 127 sa ingon nga usa ka variable ug magadugang sa 1 niini, ang resulta kinahanglan nga 128. Apan, kini nga kantidad molabaw sa pinakataas para sa kini nga klase sa integer, busa ang gipasa nga bili "mag-wrap" ug mahimong -128.</desc>
	<solution>Hugna: Mga kinahanglanon
Siguroha nga ang tanan nga mga protocol kay hugot nga gihubit, sa ingon nga ang tanan nga out-of-bounds nga kinaiya mahimong mailhan nga yano, ug nagkinahanglan sa higpit nga pag-uyon sa protocol.

Hugna: Mga Kinahanglanon
Ang paggamit og usa ka pinulongan nga dili motugot sa kahuyang na mogawas o maghatag og mga pagtukod nga makahimo niini nga kahuyang mas sayon ​​paglikay.
Kung mahimo, pagpili og usa ka pinulongan o tig-compile nga maghimo sa pag-susi sa mga utlanan.

Hugna: Arkitektura ug Disenyo
Ang paggamit sa usa ka ibrarya nga na-vetted o balangkas nga dili motugot nga mahitabo kini nga kahuyang o maghatag og mga pagtukod nga makahimo niini nga kahuyang mas sayon ​​paglikay.
Ang paggamit sa mga librarya o mga framework nga naghimo niini nga mas sayon aron pagdumala sa kadaghanon 
nga walay wala damha nga mga sangputanan.
Mga pananglitan naglakip sa luwas nga integer na naggunit sa mga pakete sama sa SafeInt (C++) o IntegerLib (C or C++).

Hugna: Implementasyon
Magpatuman sa pag-sulod sa pagtan-aw sa bisan unsa nga numeric input para sa pinaagi sa pagtino niana 
kini anaa sa gilauman nga gilay-on. Ipatuman nga ang gipasulod na makigtagbo sa kina-ubsan ug kinatas-an nga mga kinahanglanon alang sa gipaabot nga gilay-on.
Ang paggamit sa wala naka pirma nga integer kung mahimo. Kini gihimong gipasayon na buhaton mga tseke sa katin-awan kay ang integer nag-awas. Kon ikaw kay kinahanglan mogamit sa wala'y pirma nga mga integer, siguraduha nga ang imong gilay-on kay nagtan-aw naglakip sa pinakagamay na mga bili ingon man usab sa pinakataas nga mga bili.

Hugna: Pagpatuman
Sabta ang imong programming language nagpahulagway nga representasyon ug kung giunsa kini makig-uban sa numeric calculation (CWE-681). Hatagig pagtagad sa byte nga kadaku nga mga kulangan, katukma, gipirmahan/wala gipirmahan nga mga kalainan, pagputol, pagkakabig ug pagpakita tali sa mga matang, "dili usa ka numero" nga pagkalkulo, ug paghulma tali sa mga klase, "dili-usa ka numero" nga kalkulasyon, ug kung giunsa sa imong pinulongan ang mga numero nga dako o gamay ra kaayo alang sa nagpahulagway nga representasyon niini.
Pag-amping usab sa pag-asoy para sa 32-bit, 64-bit, ug uban pang potensyal nga kalainan nga makaapekto sa numero na representasyon.

Hugna: Pagpatuman
Susiha ang compiler na mga pasidaan sa pag-ayo ug pagwagtang sa kalagmitan sa seguridad nga mga problema, sama sa gipirmahan / sa wala gipirmahan nga dili pareha. Bisan kon ang kahuyang panagsa ra nga mapahimuslan, ng usa ka kapakyasan mahimong modala ngadto sa pagkompromiso sa tibuok nga sistema.</solution>
	<reference>http://projects.webappsec.org/Integer-Overflows</reference>
	<reference>http://cwe.mitre.org/data/definitions/190.html</reference>
</vuln_item_wasc_3>

<vuln_items>wasc_4</vuln_items>
<vuln_item_wasc_4>
	<alert>Dili igo nga Pagdala na Layer nga Panalipod</alert>
	<desc>Dili igo nga Pagpadala na Layer nga Panalipod
Dili igo nga pagpadala na layer nga panalipod kay nagtugot sa komunikasyon na aron maladlad sa dili tinuod nga mga ikatulo nga tawo, paghatag og usa ka vector nga pag-atake sa pagkompromiso sa web aplikasyon at/o mangawat sa sensitibo nga impormasyon. Ang mga website kay kasagaran mogamit sa Secure Sockets Layer / Transport Layer Security (SSL / TLS) aron sa paghatag og encryption sa layer sa transportasyon. Bisan pa niana, gawas kung ang website kay gihan-ay aron magamit ang SSL / TLS ug i-configure ang paggamit sa SSL / TLS sa tukmang paagi, ang website mahimong mahuyang sa interception sa trapiko ug pag-usab.
 
Kakuwangan sa Transport Layer Encryption
Sa diha nga ang layer sa transportasyon wala ma-encrypt, ang tanang komunikasyon tali sa website ug kliyente gipadala sa tin-aw nga teksto nga nagbukas niini sa interception, injection ug redirection (nailhan usab nga usa ka tawo-sa-tunga-tunga / MITM nga pag-atake). Ang usa ka tig-atake mahimong paspas makapugong sa komunikasyon, nga naghatag kanila ug permiso sa bisag unsang sensitibo nga datos nga gipasa sama sa mga username ug mga password. Ang usa ka tig-atake kay aktibo usab na mo pag-inject/pagkuha sa kontento gikan sa komunikasyon, nga nagtugot sa tig-atake nga pagpugong ug pagpahawa sa impormasyon, pag-inject sa malisyosong pagscript, o maoy hinungdan sa kliyente nga makasulod sa layo nga dili kasaligan nga kontento. Ang tig-atake kay mahimo usab nga i-redirect ang komunikasyon sa ingon nga pamaagi nga ang website ug kliyente nga dili na makigsulti sa usag usa, apan kini baylo ang mga wala mahibaw-i nga pag-komunikasyon uban sa tig-atake sa konteksto sa gisaligang partido.

Ang Weak Cipher Support
Sa kasaysayan, ang taas nga grado sa kriptograrya kay gipugngan gikan sa pagbaligya ngadto sa gawas sa Estados Unidos. Tungod niini, ang mga website kay gi-configure aron sa pagsupporta sa mga huyang nga mga kapilian sa cryptographic alang sa mga kliyente nga gipugngan nga gamiton lamang ang mga huyang nga ciphers. Ang huyang nga mga ciphers kay dali nga ma-atake tungod sa relatibong kasayon ​​sa paglapas niini; wala pay duha ka semana sa usa ka tipikal nga kompyuter sa balay ug pipila ka mga segundo gamit ang gipahinungod nga hardware.
Karon, ang tanan nga mga modernong mga browser ug mga website kay naggamit sa mas lig-on nga encrypt, apan ang uban ka mga website gi-configure gihapon aron sa pagsuporta sa dili na dugay na huyang nga mga ciphers. Tungod niini, ang usa ka tig-atake kay mahimong makapugos sa usa ka kliyente nga i-downgrade sa usa ka huyang na cipher kung mokonekta sa website, nga nagtugot sa tig-atake aron sa pagbungkag sa huyang na encryption. Para sa kini nga rason, ang server kay kinahanglan nga i-configure lamang sa pagdawat sa mga kusgan na cipher ug dili paghatag ug serbisyo sa bisag unsang kliyente nga naghangyo ug usa ka huyang na cipher. Dugang pa, sa uban nga mga website kay nahisalaag ang pag-configure sa pagpili sa usa ka mahuyang na cipher na bisan ang kliyente kay mosuporta sa usa ka mas kusgan. Ang OWASP nagtanyag ug giya sa pagsulay alang sa SSL/TLS nga mga isyu, lakip na ang huyang na cipher nga suporta ug dili saktong pag-configure, ug adunay uban pang mga kapanguhaan ug mga himan ug ingon man.</desc>
	<solution>Bahin: Mga Kinahanglanon
Tin-aw pagtino kung unsang datos o mga kapanguhaan kay bililhon kaayo na sila kay kinahanglan panalipdan pinaagi sa pag-encrypt. Gikinahanglan nga bisan unsa nga transmisyon o pagtipig niini nga datos / nga kapanguhaan kay kinahanglan nga gamiton ang maayo nga vetted pag-encrypt sa mga algorithm.

Bagin: Arkitektura ug Desinyo
Paggamit sa hulga mga pag-modelo o uban pang mga teknik, moabaga sa imong datos kay mahimong makompromiso pinaagi sa pagbuwag o kakulangon, ug pagtino kun diin ang pag-encrypt kay mahimong mas labing epektibo. Siguruha ang datos na imong gisaligan na dapat pribado nga wala kini matuyo na gibutyag sa paggamit sa mga kahuyang sama sa dili segurado na mga pagtugot (CWE-732).

Bahin: Arkitektura ug Desinyo
Siguraduha na ang pag-encrypt kay maaayo pagsagol didto sa sistema sa pagdesinyo, kalabot pero dili kinahanglang limitado sa:
      Pag-encrypt nga kinahanglan para matapigan o ipadalang naka pribadong datos sa mga mogamit sa sistema
      Pag-encrypt na kinahanglan para mapanalipdan ang kaugalingong sistema gikan sa dili awtorisadong from unauthorized pagkabutyag o pag-usab
Pag-ila sa pagbulang sa mga kinahanglan ug mga katibuk-ang kahulogan para sa pag-encrypt:
       Usa ka pamaagi (pan., ang tiggamit lamang o gipadalgan ang kinahanglan nga naay yawe). Mahimo king makab-ot sa paggamit sa publikong yawe na kriptograpiya, o laing mga teknik nga diin ang pag-encrypt na partido (pan., ang software) dili kinahanglan nga adugay katungod sa pagsulod sa usa ka pribadong yawe.
      Duha ka pamaagi (pan., ang pag-encrypt kay mahimong awtomatikong pagbuhat alang sa usa ka tiggamit, apan ang yawe kay dapat magamit para ang plaintext kay pwedeng awtomatik na makakuha balik sa maong tiggamit). Kini kay nagkinahanglang ug pagtipig sa pribadong yawe sa usa ka format nga makuha balik lamang sa tiggamit (o tingali pinaagi sa operating system) sa paagi nga dili na makuha ug balik sa uban.

Hugna: Arkitektura ug Disenyo
Dili paghimo sa imong kaugalingon na cryptographic na mga algorithm. Ang paghimo nila sa pagladlad sa mga atake nga nasabtan pag-ayo pinaagi sa mga cryptographer. Pagbali nga enhinyero na mga teknik kay hamtong. Kung ang imong algorithm kay mahimong makumprimiso kung ang mga tig-atake kay mahibaw-an kung unsa ang pamaagi sa pagtrabaho, nan kini ilabi nga mahuyang.

Bahin: Arkitektura ug Disenyo
Pagpili usa ka maaayong pagka-vet na algorithm na kini karon giisip na usa ka kusgan pinaagi sa mga eksperto sa ilang trabaho, ug pagpili sa maayong pagsulay nga mga pagpatuman.
Pananglitan, ang US nga gobyerno nga mga sistema kay nagkinahanglan ug FIPS 140-2 nga sertipikasyon.
Sama sa tanang cryptographic nga mga mekanismo, ang source code kay dapat na magamit para sa pagtuki.
Matag adlaw gisiguro na kini dili naggamit ug karaan nga cryptography. Laing mga daan nga mga algorithm, nga naghunahuna nga magkinahanglan ug bilyon nga mga tuig sa pag-compute sa oras, karon kay mahimo nang makuha sa pila lang ka adlaw o mga oras. Kini naglakip sa MD4, MD5, SHA1, DES, ug laing mga algorithm nga kaniadto giisip nga usa ka kusgan.

Bahin: Arkitektura ug Disenyo
Pagpili sa imong sistema aron makabaton ug "luwas" nga mga lugar nga diin ang pagsalig na mga utlanan kay mahimong tin-aw nga paagi nga mapagawas. Ayaw tugota ang sensitibo nga datos sa paggawas sa pagsalig nga utlanan ug permanenteng mag-amping kung pag-interface gamit ang lawak sa gawas sa luwas nga lugar.

Mga Bahin: Implementasyon; Arkitektura ug Disenyo
Kung imong gamiton ang industriya nga giaprobahang mga teknik, kinahanglan nimo nga gamiton sila nga sakto. Ayaw putla ang mga kilid sa pagsal-ang sa kapanguhaang hilabihan nga mga lakang (CWE-325). Kining mga lakang kay makadaghan na importante para sa paglikaw sa komon nga mga atake.

Bahin: Pagpatuman
Gamita ang pagpangalan sa mga kombensiyon ug kusog sa mga matang sa pagbuhat ug sayon nga lugar kung sensitibo ang datos nga gigamit. Kung nagbuhat ng mga istraktura, mga butang, o uban pa nga komplikado nga mga butang, gibulag ang sensitibo ug dili sensitibo nga datos nga kutob sa mahimo.
Kini nagpasayon sa lugar nga mga dapit sa code na diin ang datos kay gigamit sa dili pag-encrypt.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Transport-Layer-Protection</reference>
	<reference>http://cwe.mitre.org/data/definitions/311.html</reference>
</vuln_item_wasc_4>

<vuln_items>wasc_5</vuln_items>
<vuln_item_wasc_5>
	<alert>Remote File nga Gilakip</alert>
	<desc>Ang Remote File Include (RFI) kay usa ka atake nga teknik na gigamit sa pagpahimulos sa "dynamic file include" nga mga mekanismo sa web nga mga aplikasyon. Kung kanus-a ang web nga mga aplikasyon sa pagkuha ug input sa tiggamit (URL, bili sa parameter, pan.) ug ipasa sila sa file nga naglakip ug mga sugo, ang web aplikasyon kay mahimong malimbongon sa paglakip ang hilit nga mga file nga anaay malisyoso code.

Hapit tanang web aplikasyon nga mga framework kay mosuporta sa file inclusion. Ang File Inclusion kay kasagaran gigamit para sa pagputos sa komon na code ngadto sa laing mga file nga sa ulahi kay gihisgutan sa pangunang aplikasyon na mga modyul. Kon ang usa ka web aplikasyon na mga reperensya kay naglakip sa file, ang code sa niining file nga mahimong paghimong hingpit o tin-aw sa pag tawag sa piho nga mga pamaagi. Kung ang napili nga modyul sa pag-load kay basi sa mga elemento gikan sa HTTP nga hangyo, ang web aplikasyon kay tingali mahuyang sa RFI.
Ang usa ka tig-atake mahimong mogamit ug RFI para sa:
    * Paggadan ug malisyoso na code sa server: ug bisag unsang code sa gilakip sa mga malisyoso nga file kay ipadagan sa server. Kung ang file naglakip kay walang gipadagan gamit ang pipila ka mga wrapper, code nga naa sa gilakip nga mga file kay gipadagan sa konteksto sa tiggamit sa server. Mahimo kining mag-una sa pag-kompleto sa sistema na pagkompromiso.
    * Pagpadagan sa malisyoso nga code sa mga kliyente: ang malisyoso nga code sa tig-atake kay mahimong maimpluwensyahan ang sulod sa gitubag sa gipadala sa kliyente. Ang tig-atake kay mahimong makabutang ug malisyosong code sa tubag nga gipadagan sa kliyente (pananglitan, ang Javascript mahimong kuhaon sa sesyon sa kliyente nga mga cookie).

Ang PHP kay labi nga huyang sa mga atake sa RFI tungod sa kaylap na gamit sa "gipanglakip sa file" sa PHP programming ug tungod sa mga configuration nga default sa server nga mopataas sa susceptibility sa usa ka RFI nga atake.</desc>
	<solution>Bahin: Arkitektura ug Disenyo
Sa dihang usa ka hugpong sa dawatonon nga mga butang, sama sa mga filename o mga URL, kay limitado o nailhan, paghimo ug pag-mapa gikan sa hugpong sa tinudlong input nga mga bili (sama sa numeric nga mga ID) sa mga aktwal nga mga filename o mga URL, ug gipangsalikway sa tanang ubang mga input.
Pananglitan, ang ID 1 mahimong makamapa sa "inbox.txt" ug ang ID 2 makamapa sa "profile.txt". Mga butang sama sa ESAPI AccessReferenceMap kay naghatag niini nga kapasidad.

Mga Bahin: Arkitektura ug Disenyo; Pagpadagan
Pagdagan sa imong code sa "jail" o susama sa sandbox na palibot nga nagpatuman sa higpit na mga utlanan tali sa proseso ug sa operating system. Mahimo kini nga epektibong nga pugngan kung asa ang mga file kay mahimong makasulod sa usa ka ilabing direktoryo o ang mga gipangsugo kay pwedeng mapadagan sa imong software.
Ang OS nga lebel nga mga pananglitan kay naglakip sa Unix chroot jail, AppArmor, ug SELinux. Sa kinatibuk-an, ang gipadumala nga code kay mahimong mohatag ug dugang proteksyon. Pananglitan ang java.io.FilePermission sa diha nga Java SecurityManager nga nagtugot sa imoha sa pagtakda sa mga gipangdili sa file na mga operasyon.
Kini dili mahimo nga solusyon, ug kini lamang naglimit sa epekto sa operating system; ug uban pa sa imong aplikasyon kay mahimong magpasakop gihapon aron makompromiso.
Pag-amping aron malikayan ang CWE-243 ug uban pang mga makahuyang nga may kalabutan sa mga jail.
Para sa PHP, ang tighubad kay nagtanyag ug mga pagdili sama sa open basedir o safe mode nga makahimo niini nga mas lisod para sa usa ka tig-atake nga makagawas sa aplikasyon. Gihunahuna usab ang Suhosin, na usa kini ka magahi na PHP ekstensyon, nga galakip ug nagkalainlain nga mga pilianan nga dili mapagana ang ubang mga labaw na kahadlokang PHP na mga bahin.

Bahin: Pagpatuman
Hunahunaa ang tanan nga gipasulod kay malisyoso. Mogamit ug "dawata ang maayo nga nahibal-an" sa pagsulod sa pagbalido na estratehiya i.e., gamita ang usa ka whitelist sa mga madawat nga mga input nga estrikto nga subay sa mga paghingalan. Isalikway ang bisan unsang pagsulod nga dili hugot subay sa mga paghingalan, o na nag-usab kini sa bisag unsa nga gibuhat. Ayaw pagsalig lamang sa pagpangita sa mga malisyoso o sayop nga mga pagpasulod (pan., ayaw pagsalig sa blacklist). Bisan pa niini, ang mga blacklist kay mahimong mapuslanon para sa pagmatikod sa potensyal na mga atake o pagtino sa mga gipangsulod kay perteng pagkasayopa na sila nagkinahanglan nga isalikway dayon.
Sa paghimo sa pagpasulod na pagbalido, hunahunaa ang tanan nga kalabutan sa mga kabtangan, naglakip na sa gitas-on, tipo sa pagpasulod, ang bug-os nga lugway sa gipangdawat nga mga bili, nawala o sobra nga mga pagsulod, syntax, pagkamakanunayon sa tibuuk nga mga natad, ug pagpahiuyon sa mga lagda sa negosyo. Ingon sa pananglitan sa negosyo na lohika sa pagmando, "barko" kay mahimo nga syntactically na balido tungod kay kini naglangkod lamang sa alphanumeric na mga karakter, apan dili kini usa ka balido kung ikaw nagpaabot nga ang kolor kay "pula" o "asul."
Para sa mga filename, gamita ang stringent na mga whitelist nga naglimite sa karakter nga gitakda nga gamiton. Kung mahimo, tugoti lamang ang usa ka "." nga karakter sa filename para malikayan ang pagkahuyang sama sa CWE-23, ug dili paglabot sa direktoryo nga mga separator na sama sa "/" aron malikayan ang CWE-36. Gamita ang whitelist sa gitugot na file na mga ekstensyon, nga makatabang para malikayan ang CWE-434.

Mga Bahin: Arkitektura ug Disenyo; Operasyon
Pagtipig sa library, naglakip, ug utility na mga file sa gawas sa web na dokumento nga root, kung posible. Kay kon dili, tipigi kini sa lain nga direktoryo ug gamita ang web server nga pagsulod nga kontrol nga mga kapasidad para pagpugong sa mga tig-atake gikan sa direkta nga nihangyo sa kanila. Usa sa komon na pagbansay kay mao ang paghulagway sa usa ka natino nga constant sa matag nitawag na program, dayon tan-awa para sa paglungtas sa kanunayon sa library/include na file; kung ang constant kay dili na makita, dayon ang file kay direktang gihangyo, ug mahimo kini nga mogawas pagdayon.
Kining kamahinungdanon nga nagpaubos sa kahigayunan sa usa ka tig-atake nga makalatas sa bisag unsang mekanismo sa pagprotektar na naa sa imong pundasyon sa program pero wala sa imong include na mga file. Kini usab nagpaubos sa imong pag-atake sa ubos.

Mga Bahin: Arkitektura ug Disenyo: Pagpatuman
Sabta na ang tanan na potensyal na mga lugar nga diin dili masaligan na mga pagpasulod kay makasulod kini sa imong software: mga parameter o mga argumento, mga cookie, ug uban pa nga mabasa sa network, environment na mga variable, mga reverse DNS nga lookup, mga resulta sa query, mga hangyo sa mga header, URL nga mga komponent, e-mail, mga file, mga database, ug bisag unsang gawas nga mga sistema nga naghatag ug dayon sa aplikasyon. Hinumdomi kana nga mga gipangsulod kay mahimong makaangkon ug dili diretso pinaagi sa API nga mga tawag.
Daghan na file nga pagsulod nga mga problema na mahitabo tungod ang tig-program magtuo nga ang piho nga mga gipangsulod kay dili na mausab, ilabi na ang mga cookie ug URL nga mga komponent.</solution>
	<reference>http://projects.webappsec.org/Remote-File-Inclusion</reference>
	<reference>http://cwe.mitre.org/data/definitions/98.html</reference>
</vuln_item_wasc_5>

<vuln_items>wasc_6</vuln_items>
<vuln_item_wasc_6>
	<alert>Format na String</alert>
	<desc>Format String na mga Atake na usbon ang agay sa aplikasyon sa paggamit sa string sa pag-format sa mga feature sa librarya sa pag-access sa uban nga memorya na luna. Mga kaputli nga mahitabo kon ang datos nga gihatag sa tiggamit na gigamit direkta ingon nga formatting string na pagsulod na alang sa pipila C/C++ na mga gimbuhaton (e.g. fprintf, printf, sprintf, setproctitle, syslog, ...).

Kung ang moatake makapasa ug format na string nga naglangkob sa printf na pagkabalhin sa mga karakter (pan. "%f", "%p", "%n", ug uban pa.) na ingon nga usa ka parameter na bili sa web aplikasyon, na sila mahimong:
    * Mopadagan sa arbitrary code sa server
    * Pagbasa sa mga nagpalain sa stack
    * Hinugdan sa Cause pag-segmentasyon sa mga sala / mga software nga pagkahagsa

Ang Format String na mga atake kay naay kalabutan sa ubang mga pag-atake sa Threat Classification: Buffer Overflows ug Integer Overflows. Ang tanan nga tulo kay naba base sa ilang abilidad sa pagmaniobra sa panumduman o ilang interpretasyon sa pamaagi nga nag-amot sa tumong sa tig-atake.</desc>
	<solution>Bahin: Mga Kinahanglanon
Pagpili ug usa ka pinulongan nga wala'y hilisgutan sa iyang apan.

Bahin: Pagpatuman
Siguroha nga ang tanan nga format string na mga kalihokan kay nagpasa ug usa ka static na string nga dili makontrol sa usa ka tiggamit ug nga ang tukmang numero sa mga argumento kay kanunay nga gipadala ngadto nianang buluhatonon ug ingon man. Kon posible ang tanan, gamita ang kalihokan nga dili mosuporta sa %n na operator sa format na mga string.
Pagtukod: Sunda ang mga pasidaan sa mga compiler ug mga linker, kay tungod sila mahimong nga moalerto kanimo sa dili saktong paggamit.
</solution>
	<reference>http://projects.webappsec.org/Format-String</reference>
	<reference>http://cwe.mitre.org/data/definitions/134.html</reference>
</vuln_item_wasc_6>

<vuln_items>wasc_7</vuln_items>
<vuln_item_wasc_7>
	<alert>Ang Buffer Overflow</alert>
	<desc>Ang Buffer Overflow kay usa ka sayop na mahitabo kon dugang datos kay nasulat sa usa ka bloke sa panumduman, o buffer, kay sa buffer na gigahin sa paggunit. Pagpahimulos sa usa ka buffer overflow nga nagtugot sa usa ka tig-atake nga usbon ang mga bahin sa target nga proseso sa address nga luna. Kini nga abilidad kay pwede nga magamit para sa usa ka numero sa mga katuyoan, lakip na ang mosunod:
    * Pagkontrola sa proseso sa pagpadagan
    * Pagpadagan sa proseso
    * Pagbag-o sa sulod nga mga variable

Ang tumong sa tig-atake kay halos kanunay nga kontrolon ang target na proseso sa pagpadagan. Mao kini ang nahuman pinaagi sa pag-ila sa function pointer sa panumduman nga pwedeng mausab, direkta o dili direkta, paggamit sa overflow. Sa dihang usa ka pointer ang gigamit sa programa para pagdumala sa programa sa pagpadagan gamit ang paglukso o tawag sa pagtudlo, ang tig-atakeng maghatag ug pagpanudlo sa dapit kay gamiton, sa ingon nga nagtugot ang tig-atake sa pagkontrolar sa proseso.

Sa daghang mga kaso, ang function pointer kay giusab para i-reperensya ang usa ka dapit na diin ang tig-atake kay nabutang ug pagnatipon sa makina-piho nga mga pagtudlo. Kini nga mga pagtudlo kay kasagarang gihisgotan sa ingon nga shellcode, sa paghisgot sa makatuoran na ang mga moatake kay kasagaran buot magpatunghag ug usa ka command-line na environment, o shell, sa konteksto sa nagdagan nga proseso.

Ang Buffer overflows kay kasagaran labing naglangkit uban sa software nga gisulat sa C ug C++ nga programming languages na tungod sa ilang kaylap na gamit ug abilidad sa paghimo ug direktang memorya nga manipulasyon sa komon na programming na mga gipangtukod. Kini kay kinahanglan ipasabot, nga bisan pa niana, ang buffer overflows kay mahimong maglungtad sa bisag unsang programming environment nga diin ang direkta na manipulasyon sa memorya kay gitugot, nga bisan pinaagi sa mga sayop sa compiler, runtime na mga library, o mga bahin sa language mismo.
</desc>
	<solution>Hugna: Mga Kinahanglanon
Ang paggamit og usa ka pinulongan nga dili motugot sa kahuyang na mogawas o maghatag og mga pagtukod nga makahimo niini nga kahuyang mas sayon ​​paglikay.
Pananglitan, daghan nga mga language nga naghimo sa ilang kaugalingong pagdumala sa memorya, sama sa Java ug Perl, nga dili sakop sa buffer overflows. Ubang mga language, sama sa Ada ug C#, kay kasagaran nagtagana ug proteksyon sa overflow, apan ang proteksyon na mahimong mabaldado sa programmer.
Pagmatngon nga usa ka interface sa language sa lumad na code kay mahimong magpasakop sa mga overflow, bisan kon ang language sa iyang kaugalingon nga theoretically nga luwas.

Hugna: Arkitektura ug Disenyo
Ang paggamit sa usa ka ibrarya nga na-vetted o balangkas nga dili motugot nga mahitabo kini nga kahuyang o maghatag og mga pagtukod nga makahimo niini nga kahuyang mas sayon ​​paglikay.
Mga pananglitan na naglakip sa Safe C String Library (SafeStr) na gumikan kang Messier ug Viega, ug ang Strsafe.h na library na gikan sa Microsoft. Kini nga mga library kay nagahatag ug mas luwas na mga bersyon sa nag-anam-anam nga paggunit sa string nga mga bahin. Dili kini usa ka kompleto nga solusyon, tungod kay daghan ang mga buffer overflow nga walay kalabutan sa mga string.

Bahin: Pagtukod ug Pagpundok
Pagpadagan o pag-compile sa imong software gamit ang mga bahin niini o mga ekstensyon nga awtomatikong naggahatag ug proteksyon nga mekanismo nga nagmitigate o nagpawala sa buffer overflows.
Pananglitan, pipila ka mga compiler ug mga ekstensyon nga naghatag ug awtomatik na buffer overflow nga mekanismo na nagatan-aw nga gitukod sa pagcompile sa code. Mga Pananglitan nga naglakip sa Microsoft Visual Studio /GS na flag, Fedora/Red Hat FORTIFY SOURCE GCC na flag, StackGuard, ug ProPolice.

Bahin: Pagpatuman
Hunahunaa ang pagsunod sa sumusunod nga mga lagda kon maggahin ug pagdumala sa panumduman sa aplikasyon:
      Doble nga pagsusi sa imong buffer na sama kadako nga ingon sa imong paghisgot.
      Kon mogamit ug mga kalihokan nga nagdawat ug numero sa bytes nga kopya, na sama sa strncpy(), na hibaloa kana nga kung ang destinasyon sa buffer size kay managsama sa tinubdan na buffer size, kini dili NULL-terminate na string.
      Susiha ang buffer na mga utlanan kung nagtawag sa kini nga bahin sa usa ka laang ug siguroha nga ikaw kay wala sa kakuyaw sa pagsulat sa karaan na gigahin na luna.
      Kung kinahanglan, pamutlon ang tanang gipangsulod na mga string sa usa ka makatarunganon na gitas-on sa wala pa sila moagi sa pagkopya ug pagdugtong nga mga bahin.

Bahin: Operasyon
Gamita ang usa ka bahin nga pareha sa Address Space Layout Randomization (ASLR).

Gamita ang CPU ug operating system na nagtanyag ug Data Execution Protection (NX) o kapareha niini.

Hugna: Pagpatuman

Ilisan ang wala sa linya nga nakopya nga mga gimbuhaton nga naay susama nga gamit mosuporta sa gitas-on sa mga argumento, sama sa strcpy uban sa strncpy. Paghimo niini kung sila kay dili magamit.
</solution>
	<reference>http://projects.webappsec.org/Buffer-Overflow</reference>
	<reference>http://cwe.mitre.org/data/definitions/119.html</reference>
</vuln_item_wasc_7>

<vuln_items>wasc_8</vuln_items>
<vuln_item_wasc_8>
	<alert>Ang Cross-site Scripting</alert>
	<desc>Ang Cross-site Scripting (XSS) kay usa ka atake nga teknik nga naglakip sa pag-echo sa gibutang sa tig-atake ngadto sa browser sa tiggamit. Ang browser na pananglit kay mahimong usa ka sumbanan nga kliyente na browser, o ang browser object embedded sa usa ka produkto sa software na sama sa browser nga anaa sa WinAmp, usa ka RSS nga mobasa, o usa ka kliyente para sa email. Ang code mismo kay kasagaran nakasulat sa HTML/JavaScript, apan mahimo usab nga ipaabot sa VBScript, ActiveX, Java, Flash, o bisag unsang gi-suporta sa browser na teknolohiya.
Sa dihang ang usa ka tig-atake kay makakuha ug usa ka browser sa tiggamit para mapadagan ang iyang code, ang code kay modagan sa sulod sa konteksto sa seguridad (o zone) sa naghost sa web site. Uban niining level sa pribilehiyo, ang code kay naay abilidad nga mabasa, mabag-o ug mapadala sa bisag kinsa nga sensitibo nga datos nga ginakuha sa browser. Ang Cross-site Scripted nga tiggamit kay mahimong ang iyang account kay makuha (kawatan ug cookie), ang ilang browser kay nagbalhin ngadto sa laing lugar, o mahimo nga gipakita nga malimbongon nga kontento nga gitugyan sa web site na ilang gibisita. Ang Cross-site Scripting kay moatake sa esensya na pagkompromiso sa pagsalig na relasyon tali sa tiggamit ug ang web site. Ang mga aplikasyon na paggamit sa browser object nga mga instance nga moload sa sulod nga gikan sa file system kay mahimong ipatuman ang code nga ubos sa lokal nga makina sa zone na nagtugot para sa pagkomprimiso sa sistema.

Adunay tulo ka mga matang sa Cross-site Scripting nga mga atake: dili mopadayon, mopadayon ug naka DOM-based.
Ang Dili mopadayon nga mga atake ug DOM-based na mga atake kay nagkinahanglan ug tiggamit sa pagbisita ug usa ka espesyal nga gimugna nga naka-link laced nga adunay malisyoso nga code, o bisitaha ang malisyoso na web page nga naglangkod sa web form, na kung gibutang sa hugang nga lugar, kay naay moatake. Paggamit sa malisyoso nga form kay kasagaran matabo kung kanus-a ang mahuyang na kapanguhaan nga modawat lamang ug HTTP POST na mga hangyo. Sa maong kaso, ang form kay pwede masumite na awtomatiko, nga walay apil ang kahibaw sa biktima (pan. pinaagi sa paggamit sa JavaScript). Pinaagi sa pagkilk sa malisyoso nga link o pagsumiter sa malisyoso na form, ang XSS payload kay makakuha ug naka-echo nga balik ug makadawat ug gihubad na browser sa tiggamit ug gipadagan. Usa pa ka laing teknik ang paghatag ug hapit arbitraryo nga mga hangyo (GET ug POST) na pinaagi sa paggamit sa usa ka nakabutang na daan sa kliyente, sama sa Adobe Flash.
Padayon nga mga atake mahitabo kon ang malisyoso na code kay gisumite sa usa ka web site na naa naka butang nga dugay na. Mga pananglitan sa mga paboritong mga target sa moatake kay kanunay naglakip sa mga mensahe sa board post, web mail nga mga mensahe, ug web chat na software. Ang dili mapugngan nga tiggamit kay dili kinahanglan nga makig-istorya sa bisag kinsa nga dugang na site/link (pan. usa ka tig-atake sa site o usa ka malisyoso na link gipadala gamit ang email), yano lang na matan-aw sa web page ang sulod sa code.</desc>
	<solution>Hugna: Arkitektura ug Disenyo
Ang paggamit sa usa ka ibrarya nga na-vetted o balangkas nga dili motugot nga mahitabo kini nga kahuyang o maghatag og mga pagtukod nga makahimo niini nga kahuyang mas sayon ​​paglikay.
Mga pananglitan sa mga library ug mga framework na makahimong makasayon sa pagmugnag husto nga pag-encode sa output nga naglakip sa Anti-XSS library ni Microsoft, ang OWASP ESAPI Encoding na modyul, ug ang Apache Wicket.

Mga Bahin: Pagpatuman; Arkitektura ug Disenyo
Sabta ang konteksto nga diin ang imong datos ay gamiton ug ang pag-encode kay gilauman. Kini kay ilabi ka importante kon magpadala ug datos nga tali sa nagkalainglaing mga komponent, o sa diha nga pagmugna sa mga output nga mahimong adunay sunod na daghang mga encoding na sa samang higayon, sama sa mga web page o o multi-part mail na mga mensahe. Pagtuon sa tanan kay gilauman na mga protocol sa komunikasyon ug representasyon sa datos sa pagtino sa kinahanglan ang encoding na mga estratehiya.
Alang sa bisan unsa nga datos kay ipagawas sa lain nga web page, ilabi na bisag unsa na datos nga nadawat gikan sa gawas nga mga gipangsulod, gamita ang angay nga pag-encode para sa tanan nga dili alphanumeric nga mga karakter.
Konsulta ang XSS Prevention Cheat Sheet para sa daghan nga mga detalye sa mga tipo sa encoding ug pag-ikyas na sila kay kinahanglan.

Bahin: Arkitektura ug Disenyo
Alang sa bisag unsa nga pagtan-aw sa seguridad na gibuhat sa bahin sa kliyente, siguroha nga kini nagtan-aw sa balikbalik sa bahin sa server, aron malikayan ang CWE-602. Ang mga tig-atake kay mahimong maka-bypass sa bahin sa kliyente sa pag-usab sa mga bili paghuman sa pagtan-aw kung unsa na ang nabuhat, o pinaagi sa pagbag-o sa kliyente para matangtang ang bahin sa kliyente nga pangtan-aw sa kinatibuk-an. Dayon, kini nga mga gipangbag-o na mga bili, kay mahimong isumite sa server.

Kon anaa, gamiton ang structured na mga mekanismo para awtomatiko na mopatuman sa pagbulag sa datos ug sa code. Kini nga mga mekanismo kay makahimong makahatag sa may kalabutan nga pagkutlo, encoding, ug pagbalido nga awtomatiko, imbis nga mosalig sa developer sa paghatag niini nga kapabilidad sa matag punto nga diin ang output kay namugna.

Bahin: Pagpatuman
Para sa matag usa nga web page nga gipangmugna, gamita ug paghinganlan ang karakter encoding na sama sa ISO-8859-1 o UTF-8. Sa diha nga ang encoding kay wala matino, ang web browser kay mahimong mopili ug lain nga encoding pinaagi sa pagtag-an kung unsa nga encoding ang tinuod nga gigamit sa web page. Mahimo kini nga hinungdan nga ang web page sa pagtratar ug pipila sa mga sunodsunod nga espesyal, pagabli sa kliyente para maliputon ang XSS nga mga atake. Tan-awa ang CWE-116 para sa dugang nga mga mitagation na naay kalabutan sa encoding/pag-ikyas.

Para matabangan ang pagpagaan sa XSS na mga atake batok sa tiggamit na sesyon cookie, ang paghimo sa sesyon para mahimong HttpOnly. Sa mga browser na mosuporta ug HttpOnly na bahin (sama sa dugang pa na bag-o nga mga bersyon sa internet Explorer ug Firefox), kini nga attribute kay makapugong sa sesyon cookie sa tiggamit gikan sa pagkahimong accessible sa makadaot sa kliyente na mga script na mogamit ug document.cookie. Dili kini usa ka kompleto nga solusyon, sukad ang HttpOnly kay dili suportado sa tanang mga browser. Mas importante, ang XMLHTTPRequest ug uban pa na gamhanan nga browser nga mga teknolohiya kay naghatag ug read access sa HTTP nga mga header, lakip na ang Set-Cookie na header nga diin ang HttpOnly flag kay gibutang.

Hunahunaa nga ang tanan nga input kay malisyoso. Mogamit ug "dawata ang maayo nga nahibal-an" sa pagsulod sa pagbalido na estratehiya i.e., gamita ang usa ka whitelist sa mga madawat nga mga input nga estrikto nga subay sa mga paghingalan. Isalikway ang bisan unsang pagsulod nga dili hugot subay sa mga paghingalan, o na nag-usab kini sa bisag unsa nga gibuhat. Ayaw pagsalig lamang sa pagpangita sa mga malisyoso o sayop nga mga pagpasulod (pan., ayaw pagsalig sa blacklist). Bisan pa niini, ang mga blacklist kay mahimong mapuslanon para sa pagmatikod sa potensyal na mga atake o pagtino sa mga gipangsulod kay perteng pagkasayopa na sila nagkinahanglan nga isalikway dayon.

Sa paghimo sa pagpasulod na pagbalido, hunahunaa ang tanan nga kalabutan sa mga kabtangan, naglakip na sa gitas-on, tipo sa pagpasulod, ang bug-os nga lugway sa gipangdawat nga mga bili, nawala o sobra nga mga pagsulod, syntax, pagkamakanunayon sa tibuuk nga mga natad, ug pagpahiuyon sa mga lagda sa negosyo. Ingon sa pananglitan sa negosyo na lohika sa pagmando, "barko" kay mahimo nga syntactically na balido tungod kini naglangkod sa alphanumeric nga mga karakter, apan dili kini usa ka balido kung ikaw nagpaabot ug mga kolor na sama sa "pula" o "asul."

Siguroha nga ikaw mobuhat ug input nga pagbalido sa maayong pagpasabot sa mga interface na sulod sa aplikasyon. Kini makatabang sa pagpanalipod sa aplikasyon na bisan kon usa ka komponent kay gigamit pag-usab o pagbalhin sa ubang dapit.
	</solution>
	<reference>http://projects.webappsec.org/Cross-Site-Scripting</reference>
	<reference>http://cwe.mitre.org/data/definitions/79.html</reference>
</vuln_item_wasc_8>

<vuln_items>wasc_9</vuln_items>
<vuln_item_wasc_9>
	<alert>Ang Cross Site Request Forgery</alert>
	<desc>Usa ka cross-site nga hangyo sa pagkopya kay usa ka pag-atake nga naglangkit sa pagpugos sa usa ka biktima para mohatag ug HTTP na hangyo ngadto sa target na destinasyon nga walay ilang pagkahibalo o katuyuan sa paghusto sa aksyon nga ingon sa biktima. Ang hinungdan kay ang aplikasyon na katuyoan sa paggamit ug mahibal-an na URL/form na mga aksyon sa usa ka balik-balik nga pamaagi. Ang kinaiyahan sa atake mao ang CSRF sa pagpahimulos sa pagsalig nga ang usa ka web site nga adunay alang para sa usa ka tiggamit. Sa kasukwahi, ang cross-site scripting (XSS) kay nagpahimulos sa pagsalig nga ang usa ka tiggamit nga adunay alang sa usa ka web site. Sama sa XSS, ang CSRF nga mga atake kay dili kinahanglan ang cross-site, apan mahimo kini. Ang Cross-site nga hangyo sa pagkopya kay nailhan usab nga CSRF, XSRF, usa ka klik nga atake, pagsakay sa sesyon, paglibog sa deputado, ug sea surf.

Ang CSRF nga mga atake kay epektibo sa daghang mga sitwasyon, na naglakip sa:
    * Ang biktima nga adunay aktibo nga sesyon sa target na site.
    * Ang biktima kay gipamatuod gamit ang HTTP na auth sa target na site.
    * Ang biktima kay naa ra sa pareho nga lokal network nga ingon nga target site.

Ang CSRF kay adunay una nga gigamit sa paghimo ug aksyon batok sa target site na gigamit nga mga pribilehiyo sa biktima, apan bag-o lang nga mga teknik kay nadiskobrehan aron magpadayag sa impormasyon na pinaagi sa pag-access sa tubag. Ang risgo sa impormasyon nga gibutyag kay mikusog ug maayo kon ang target site kay mahuyang sa XSS, tungod kay ang XSS kay mahimong gamiton isip plataporma para sa CSRF, nagtugot sa atake sa pag-operate na sulod sa utlanan na susama sa gigikanan nga palisiya.</desc>
	<solution>Hugna: Arkitektura ug Disenyo
Ang paggamit sa usa ka ibrarya nga na-vetted o balangkas nga dili motugot nga mahitabo kini nga kahuyang o maghatag og mga pagtukod nga makahimo niini nga kahuyang mas sayon ​​paglikay.
Pananglitan, gamita ang anti-CSRF nga mga pakete na sama sa OWASP CSRFGuard.

Bahin: Pagpatuman
 Siguroha nga ang imong aplikasyon kay libre sa cross-site scripting nga mga isyu, tungod kay kadaghanan sa CSRF nga mga depensa kay mahimong malabwan gamit ang kontrola sa tig-atake nga script.

Bahin: Arkitektura ug Disenyo
Paghimo ug usa ka talagsaon nga nonce para sa matag usa nga form, ibutang ang nonce sulod sa form, ug susihon ang nonce gikan sa pagdawat sa form. Siguroha nga ang nonce kay dili mamatikdan (CWE-330).
Timan-i nga kini kay mahimong malabwan gamit ang XSS.

Tan-awa ilabina ang kahadlokang mga operasyon. Sa diha ang tiggamit mohimo ug kahadlokang operasyon, magpadala ug bulag na pagkumpirma na mga hangyo para pagsiguro nga ang tiggamit nagtuyo sa pagbuhat sa maong operasyon.
Timan-i nga kini kay mahimong malabwan gamit ang XSS.

Gamita ang ESAPI Session Management na kontrol.
Kini nga kontrol kay naglakip sa komponent para sa CSRF.

Ayaw gamita ang GET na pamaagi para sa bisag unsa hangyo nga nag-aghat sa pagbag-o sa estado.

Bahin: Pagpatuman
Tan-awa ang HTTP Referer nga header para matan-aw kung ang gihangko nga naggikan sa gilauman nga pahina. Kini kay mahimong makabungkag sa lehitimo nga katayuon, tungod kay ang mga tiggamit o mga proxy kay tinggali dili naka-disable sa pagpadala sa Referer para sa privacy nga mga rason.</solution>
	<reference>http://projects.webappsec.org/Cross-Site-Request-Forgery</reference>
	<reference>http://cwe.mitre.org/data/definitions/352.html</reference>
</vuln_item_wasc_9>

<vuln_items>wasc_10</vuln_items>
<vuln_item_wasc_10>
	<alert>Denial of Service</alert>
	<desc>Ang Denial of Service (DoS) kay usa ka teknik sa pag-atake uban sa katuyoan sa pagpugong sa usa ka web site nga gikan sa pagserbisyo sa normal nga tiggamit nga aktibidad. Ang DoS nga mga atake, nga gikan sa sayon nga normal nga ipadapat sa network na layer, na mahimo usab nga posible sa aplikasyon layer. Kini nga mga malisyoso na mga pag-atake kay mahimong molampas pinaagi sa gigutom nga sistema sa kritikal na mga kapanguhaan, huyang nga pagpahimulos, o abusar sa katuyoan.

Daghan na higayon na ang mga atake sa DoS kay mosulay sa pagkaon tanan sa magamit na mga kapanguhaan sama sa: CPU, memory, disk space ug uban pa. Kung adunay usa ka kritikal na kapanguhaan nga makaabot sa hingpit na paggamit, ang web site kay normal na dili masudlan.

Sa sa web aplikasyon karon na mga palibot kay naglakip sa web server, database server ug usa ka authentication server, ang Dos na anaa sa aplikasyon na layer lay motarget sa matag independente nga mga komponent. Di pareha sa Dos nga anaa sa network na layer, na diin ang dako nga numero sa koneksyon kay nagsulay ug nagkinahanglan, ang DoS nga anaa sa aplikasyon na layer kay mas simple na buhat na buhatonon.</desc>
	<solution>Bahin: Arkitektura ug Disenyo

Desinyo sa paglihok sa mga mekanismo ngadto sa sistema sa arkitektura. Ang labing maayong proteksyon mao ang paglimit sa kantidad sa mga kapanguhaan nga ang dili awtorisado nga tiggamit kay makahimo ug gastohonon. Ang usa ka kusog nga pagkatinuod ug modelo sa access kontrol kay makatabang pagpugong sa mga pag-atake gikan sa pag-usab sa una nga dapit. Ang login na aplikasyon kay kinahanglan panalipdan batok sa mga atake sa DoS nga kutob sa iyang mahimo. Paglimitar sa database access, nga tingali pinaagi sa pag-cache nga resulta, kay makatabang na mapakunhod ang mga gipanggasto nga kapanguhaan. Sa dugang pa nga limit sa potensyal para sa atake nga DoS, hunahunaa ang pagsubay sa gidaghanon sa mga hangyo nga nadawat gikan sa mga tiggamit ug pagbabag sa mga hangyo nga labaw sa usa ka gihan-ay nga sukaranan nga rate.

Pagtangtang sa kapanguhaan nga mga atake nagkinahanglan na ang target na sistema kay mahimo nga:
      giila nga ang atake ug pagbalibad na ang tiggamit sa dugang nga pag-access para sa gihatag nga oras o
      parehas nga mga hagit sa tanan nga mga hangyo aron mahimo kini nga mas lisod sa paggamit sa mga kahinguhaan na mas paspas kaysa ilang mga  gipangbuy-an. 

Ang una sa mga solusyon niini kay ang isyu sa iyang kaugalingon nga bisan pa, tungod kay kini motugot sa mga tig-atake na mapugan ang paggamit sa sistema nga pinaagi sa partikular na balidong tggamit. Kung ang tig-atake kay nagapakaaron-ingnon na usa ka balido nga tiggamit, kay mahimo niya na mapugngan ang tiggamit sa pag-access sa server sa pangutana.

Sa ikaduha nga solusyon kay yano nga pagkalisod aron sa epektibo nga institute -- ug bisan pa nga husto ang paghimo, kini wala maghatag ug usa ka bug-os nga solusyon. Kini yano gihimo sa tig-atake nga nagkinahanglan ug mga kapanguhaan sa bahin sa tig-atake.

Siguroha nga ang mga protocol kay adunay mga limitasyon sa gibutang ibabaw kanila.

Bahin: Pagpatuman
Siguroha nga tanan nga mga kapakyasan sa gigahin na kapanguhaan kay nagbutang sa sistema na luwas nga postura.</solution>
	<reference>http://projects.webappsec.org/Denial-of-Service</reference>
	<reference>http://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_10>

<vuln_items>wasc_11a</vuln_items>
<vuln_item_wasc_11a>
	<alert>Brute Forcing Log-in na mga Kredensyal</alert>
	<desc>Usa ka brute force na atake kay usa ka pamaagi sa pagtino sa wala mailhi na bili pinaagi sa paggamit sa awtomatiko na proseso aron sa pagsulay sa usa ka dako nga numero sa posible nga mga bili. Ang atake kay naghimulos sa kamatuoran nga ang entropy sa mga bili kay mas gamay kaysa nakit-an. Pananglitan, samtang usa ka 8 na karakter na alphanumeric password na mahimong 2.8 trilyon nga posible nga mga bili, daghan nga mga tawo na mopili sa ilang mga password gikan sa mas gamay na subset nga naglangkob sa komon nga mga pulong ug mga termino.

Ang labing komon na type sa usa ka brute force na atake sa web na mga aplikasyon kay ang atake batok sa log-in na mga kredensyal. Sukad ang mga tiggamit kay nagkinahanglan na hinumduman ang mga password, sila kanunay nga mopili ug sayon na pagsag-ulo sa mga pulong o mga phrase na ingon man ang mga password, nga naghimo sa usa ka brute force na atake na mogamit sa diksiyonaryo nga mapuslanon. Ang maong pag-atake nagsulay pag log-in sa sistema gamit ang dako nga listahan sa mga pulong ug mga hugpong na ingon sa potensyal na mga password sa kanunay nga gitawag ug usa ka "atake sa pulong nga listahan" o usa ka "atake sa diksiyonaryo". Pagsulay sa mga password kay naglakip usab sa mga pulong nga komon sa mga password, sama sa namugna nga pinaagi sa pag-ilis sa "o" sa "i" nga adunay "1" ug ingon man ang personal na impormasyon na naglakip sa mga pangalan sa membro sa pamilya, adaw natawhan ug mga numero sa telepono.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11a>

<vuln_items>wasc_11b</vuln_items>
<vuln_item_wasc_11b>
	<alert>Brute Forcing na Sesyon na Tig-tanaw</alert>
	<desc>Usa ka brute force na atake kay usa ka pamaagi sa pagtino sa wala mailhi na bili pinaagi sa paggamit sa awtomatiko na proseso aron sa pagsulay sa usa ka dako nga numero sa posible nga mga bili. Ang atake kay naghimulos sa kamatuoran nga ang entropy sa mga bili kay mas gamay kaysa nakit-an. Pananglitan, samtang usa ka 8 na karakter na alphanumeric password na mahimong 2.8 trilyon nga posible nga mga bili, daghan nga mga tawo na mopili sa ilang mga password gikan sa mas gamay na subset nga naglangkob sa komon nga mga pulong ug mga termino.

Sukad na ang HTTP kay usa ka stateless na protocol, aron pagmintinar ang estado na web na mga aplikasyon kay nagkinahanglan na siguruhon na ang sesyon na tig-tanaw kay nagpadala sa browser sa matag hangyo. Ang sesyon nga tig-tanaw kay pinaka komon na gitipigan sa HTTP cookie o URL. Gamit ang brute force na atake, ang tig-atake kay makatagna sa sesyon na tig-tanaw sa uban nga tiggamit. Mahimo kini nga ang tig-atake pagpakaaron-ingnon an ang tiggamit, pagkuha sa personal na impormasyon ug pagbuhat sa mga aksyon alang sa tiggamit.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11b>

<vuln_items>wasc_11c</vuln_items>
<vuln_item_wasc_11c>
	<alert>Brute Forcing sa mga Direktoryo ug mga File</alert>
	<desc>Usa ka brute force na atake kay usa ka pamaagi sa pagtino sa wala mailhi na bili pinaagi sa paggamit sa awtomatiko na proseso aron sa pagsulay sa usa ka dako nga numero sa posible nga mga bili. Ang atake kay naghimulos sa kamatuoran nga ang entropy sa mga bili kay mas gamay kaysa nakit-an. Pananglitan, samtang usa ka 8 na karakter na alphanumeric password na mahimong 2.8 trilyon nga posible nga mga bili, daghan nga mga tawo na mopili sa ilang mga password gikan sa mas gamay na subset nga naglangkob sa komon nga mga pulong ug mga termino.

Kung ang mga file naa sa sulod sa mga direktoryo ug nagserbisyo sa web server pero dili kini nagsumpay sa bisag asa, pag-access sa maong mga file kay nagkinahanglan ug pagkaila sa pangalan sa file. Sa pipila ka mga kaso nga katong mga file na nahibin sa sayop: pananglitan ang usa ka backup file kay awtomatiko na gibuhat kung nag-edit ka ug usa ka file o mga nahibilin gikan sa daan nga bersyon sa web aplikasyon. Sa ubang mga kaso nga mga file kay tinuyo nga gibilin na dili nakasumpay nga ingon sa usa ka "seguridad sa pagkalubong" na mekanismo na nagtugot lamang sa mga tawo nga nakahibalo sa mga pangalan sa file aron ma-access kini.

Usa ka brute force na atake kay naningkamot nga makit-an ang wala nakasumpay sa file pinaagi sa pag-access sa usa ka dako nga numero sa mga file. Ang listahan sa gipugos na mga pangalan sa file kay mahimong makuha gikan sa listahan sa nailhan na potensyal na mga file o base sa mga laing mga makita na mga file sa web site. Daghan na impormasyon sa brute forcing na mga direktoryo ug mga file kay makita sa nahilakip na kahuyang, nahibal-an na kapanguhaan nga dapit.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11c>

<vuln_items>wasc_11d</vuln_items>
<vuln_item_wasc_11d>
	<alert>Brute Forcing sa Impormasyon sa Credit Card</alert>
	<desc>Usa ka brute force na atake kay usa ka pamaagi sa pagtino sa wala mailhi na bili pinaagi sa paggamit sa awtomatiko na proseso aron sa pagsulay sa usa ka dako nga numero sa posible nga mga bili. Ang atake kay naghimulos sa kamatuoran nga ang entropy sa mga bili kay mas gamay kaysa nakit-an. Pananglitan, samtang usa ka 8 na karakter na alphanumeric password na mahimong 2.8 trilyon nga posible nga mga bili, daghan nga mga tawo na mopili sa ilang mga password gikan sa mas gamay na subset nga naglangkob sa komon nga mga pulong ug mga termino.

Ang Shopping online kay anaay gikawat na mga credit card na kasagaran nagkinahanglan ug impormasyon dugang pa sa credit card na numero, na labing kasagaran kay ang CVV/SCS ug/o petsa sa expiration. Usa ka mangingilad kay mahimo adunay kinawat na credit card na numeron na walay dugang pa nga impormasyon. Pananglitan ang CVV/CSC kay wala naka imprinta sa card o gitago sa magnetic stripe para dili koni makolekta pamaagi sa mekanikal o magnetic credit card swiping na mga device.

In order to fill in the missing information the hacker can guess the missing information using a brute force technique, trying all possible values.
    * Guessing CVV/CSC requires only 1000 or 10000 attempts as the number is only 3 or 4 digits, depending on the card type.
    * Guessing an expiration date requires only several dozen attempts.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11d>

<vuln_items>wasc_12</vuln_items>
<vuln_item_wasc_12>
	<alert>Content Spoofing</alert>
	<desc>Ang Content Spoofing kay usa ka atake na teknik na nagtugot sa tig-atake sa pag-inject sa usa ka malisyoso na payload nga sa ulahi kay sayop na paghulagway sa lehitimo nga sulod sa usa ka web aplikasyon.
 
Text Lamang na Spoofing sa Sulod
Usa ka komon pagduol sa pagusab-usab na pagtukod sa mga panid naglangkit sa lumalabay sa lawas o mga bahin sa kana nga mga panid gamit ang query string na bili. Sa pagduol niini ay usa ka komon sa mga sayop na mga panid, o mga site nga nagahatag ug istorya o mga balita sa mga gipangsulod. Ang sulod nga bungat sa parameter kay sa ulahi na makita sa panid para paghatag sa sulod para sa panid.
 
Markup Reflected na Spoofing sa Sulod. Pananglita, ang ginikanan na lugar sa usa ka frame <frame src="http://foo.example/file.html"/>) kay mahimong matino sa usa ka URL parameter na bili. (http://foo.example/page?frame_src=http://foo.example/file.html). Ang usa ka tig-atake kay mahimong makailis sa "frame_src" na parameter na bili nga anaay "frame_src=http://attacker.example/spoof.html". Dili pareha sa mga redirector, kon ang resulta sa web page kay naggahatag sa browser location bar kay dayag na nagpabilin ubos sa tiggamit na gilauman na domain (foo.example), pero ang langyaw na datos (attacker.example) kay gitabangan pinaagi sa lehitimong sulod.

Ilabi na ang gihimo na mga link kay mahimong mapadala ngadto sa usa ka tiggamit gamit ang e-mail, paspas nga mga mensahe, nahibilin sa gipang-post sa bulletin board, o nagpugos sa mga tiggamit pinaagi ka sa usa ka Cross-site Scripting na pag-atake. Kung ang tig-atake kay makadawat sa usa ka tiggamit nga mobisita sa usa ka web page na gitudlo pinaagi sa ilang malisyosong URL, ang tiggamit kay motuo siya na nagtan-aw ug tunuod na sulod gika sa usa ka lokasyon kon dili siya. Ang mga tiggamit lay hingpit na mosalig sa naka-spoof na sulod na sukad ang lokasyon sa browser kay nagpakita ug http://foo.example, na sa pagkatinuod ang nasa ubos na HTML frame kay naghisgot sa http://attacker.example.

Kini nga atake kay nagpahimulos sa pagsalig nga relasyon nga gitukod tali sa tiggamit ug sa web site. Ang teknik kay gigamit sa paghimo ug mga peke nga mga web page lakip na ang login na mga form, mga defacement, mga bakak na gipanggawas sa press, ug uban pa.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Content-Spoofing</reference>
	<reference>TBA</reference>
</vuln_item_wasc_12>

<vuln_items>wasc_13</vuln_items>
<vuln_item_wasc_13>
	<alert>Leakage sa Impormasyon</alert>
	<desc>Pag-leak sa Impormasyon kay usa ka makapahuyang sa aplikasyon na diin ang usa ka aplikasyon kay nagbutyag ug mga sensitibo nga datos, sama teknikal na mga detalye sa web aplikasyon, environment, o data nga piho sa tuggamit. Ang Sensitibo nga datos kay pwedeng gamiton sa usa ka tig-atake para mapahimoslan ang target na web aplikasyon, sa iyang hosting network, o iyang mga tiggamit. Busa, ang pagkaawas sa sensitibo nga datos kay dapat limitado o wala gitugot kon mahimo. Ang Pag-awas sa Impormasyon, sa labing komon na mga form niini, kay mao ang resulta sa usa o daghan nga sumusunod na mga kondisyon: Usa ka pagpakyas sa pag-scrub sa HTML/Script na mga komento kay adunay sulod na sensitibo nga impormasyon, dili sakto nga aplikasyon o mga kumpigurasyon sa server, o kalainan sa panid sa mga tubag para sa balido nga kontra sa dili balido nga datos.

Kapakyasan sa pag-scrub sa HTML/Script na mga komento una sa pagduso sa produksyon na environment kay mahimong makaresulta ug pag-awas sa sensitibo, konteksto, impormasyon na sama sa direktoryo sa istraktura, istraktura sa SQL query, ug sulod na impormasyon sa network. Kasagaran ang tig-develop kay magbilin ug mga komento sa sulod sa HTML ug/o script code para motabang na mapadali ang pag-debug o pagsinabtanay sa proseso atol sa pre-produksyon na phase. Bisan pa na dili kini makadaot sa pagtugot sa mga tig-develop nga maglakip sa inline na mga komento sa sulod sa gipangsudlan na ilang gipangbuhat, kini nga mga komento kay kinahanglan kining tangtangon sa dili pa ang publiko nga pagpagawas sa release.

Mga numero sa software bersyon ug verbose na sayop na mga mensahe (sama sa ASP.NET na mga numero sa bersyon) kay ang mga panig-ingnan sa dili sato nga server kumpigurasyon. Kini nga impormasyon kay mapahimuslanon sa tig-atake na pinaagi sa paghatag ug detalye sa gipasabot na sama sa framework, mga language, o mga pre-built function nga gigamit sa web aplikasyon. Kasagaran sa default server na mga kumpigurasyon kay nagahatag ug software bersyon na mga numero ug verbose na sayop na mga mensahe para sa pag-debug ug pag-troubleshoor na mga katuyoan. Ang Kumpigurasyon na mga gipangusab kay mahimong dili magamit ang maong mga bahin, pagpugong sa gipakita sa impormasyon niini.

Mga panid kay naghatag ug lainlaing mga tubag base sa pagkabalido sa datos na mahimo usab nga magdala sa Impormasyon na Pagka-awas; ilabina na kon ang datos kay giisip na kompidensyal na gipadayag isip resulta sa disenyo sa web aplikasyon. Mga pananglitan sa sensitibo nga datos naglakip (apan dili limitado sa): mga numero sa account, mga identifier sa tiggamitan (Numero sa lisensya sa driver, Numero sa passport, Mga numero sa Social Security, ug uban pa.) ug tiggamit-espesipiko na impormasyon (mga password, mga sesyon, ug mga address). Ang Pag-awas sa Impormasyon niini nga konteksto kay naghisgot sa pagkaladlad sa yano nga datos sa gumagamit nga giisip na kompidensyal, o sekreto, nga dili dapat kinahanglan ibutyag sa plain na pagtan-aw, na bisan ang tiggamit. Ang mga numero sa credit card ug uban pa na hilabihan nga gikontrol nga kasayuran kay maoy pangunang mga panig-ingnan sa datos sa tiggamitan na nagkinahanglan ug gugang na pagprotektar gikan sa pagkaladlad o pag-awas na bisan pa ang tukmang pag-encrypt ug pagsulod sa mga kontrol na anaa nakabutang.</desc>
	<solution>Pagpili sa imong sistema aron makabaton ug "luwas" nga mga lugar nga diin ang pagsalig na mga utlanan kay mahimong tin-aw nga paaagi nga mapaggawas. Ayaw tugota ang sensitibo nga datos sa paggawas sa pagsalig nga utlanan ug permanenteng mag-amping kung pag-interface gamit ang lawak sa gawas sa luwas nga lugar.</solution>
	<reference>http://projects.webappsec.org/Information-Leakage</reference>
	<reference>http://cwe.mitre.org/data/definitions/200.html</reference>
</vuln_item_wasc_13>

<vuln_items>wasc_14</vuln_items>
<vuln_item_wasc_14>
	<alert>Dili sakto nga Kumpigurasyon sa server</alert>
	<desc>Ang mga sayop na kumpigurasyon sa server kay ang atake na nagpahimulos sa kumpigurasyon na pagkahuyang na makita sa mga web server ug mga aplikasyon server. Daghan na mga server na moabot uban sa wala kinahanglanan nga default ug mga sample na mga file, naglakip sa mga aplikasyon, kumpigurasyon na mga file, mga script ug web na mga panid. Mahimo usab sila ug dili kinahanglan na mga serbisyo na mapagana, sama sa sulod sa pagdumala ug higit na pagdumala sa bahin. Mga pag-debug na bahin kay pwede mapagana o pagdumala na mga bahin kay mahimong ma-access sa wala mailhi na mga tiggamitan. Kini nga mga bahin kay mahimong maghatag ug usa ka paaagi sa ug ka hacker para i-bypass ang pagkatinuod nga mga pamaagi ug makaangkon ug access para sa sensitibo na impormasyon, tingali uban ang taas nga mga pribilehiyo.

Ang mga server kay mahimong maglakip ug inila nga default na mga account ug mga password. Pagpakyas sa hingpit na pagkagapos o pagmagahi sa server kay mahimong mobiya nga dili angay na ipagtakda sa file ug direktoryo na mga pagtugot. Mga sayop na mga kumpigurasyon sa SSL na mga sertipiko ug mga pag-encrypt na setting, ang paggamit sa default na mga sertipiko, ug dili sakto na pagmatuod nga pagpatuman uban sa gawas nga mga sistema na mahimong makakomprimiso sa confidentiality sa impormasyon.

Verbose ug informative na sayop na mga mensahe kay mahimong moresulta sa pagkawala sa datos, ug ang impormasyon kay gipadayag kay mahimong magamit sa paghimo sa sunod na lebel sa pag-atake. Ang dili sakto nga mga kumpigurasyon sa server software kay mahimong motugot sa direktoryo na pag-index ug pag-atake sa agianan na traversal.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Server-Misconfiguration</reference>
	<reference></reference>
</vuln_item_wasc_14>

<vuln_items>wasc_15</vuln_items>
<vuln_item_wasc_15>
	<alert>Diil sakto nga kumpigurasyon sa aplikasyon</alert>
	<desc>Ang dili sakto nga kumpigurasyon sa aplikasyon na mga atake kay nagpahimulos sa kumpigurasyon na pagkahuyang na makita sa web na mga aplikasyon. Daghan nga mga aplikasyon kay moabot uban sa wala kinahanglana ug dili luwas na mga bahin, sana sa pag-debug ug QA sa mga bahin, nga nakahimo pinaagi sa default. Kini nga mga bahin kay mahimong maghatag ug usa ka paaagi sa ug ka hacker para i-bypass ang pagkatinuod nga mga pamaagi ug makaangkon ug access para sa sensitibo na impormasyon, tingali uban ang taas nga mga pribilehiyo.

Likewise, default installations may include well-known usernames and passwords, hard-coded backdoor accounts, special access mechanisms, and incorrect permissions set for files accessible through web servers. Default samples may be accessible in production environments. Application-based configuration files that are not properly locked down may reveal clear text connection strings to the database, and default settings in configuration files may not have been set with security in mind. All of these misconfigurations may lead to unauthorized access to sensitive information.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Application-Misconfiguration</reference>
	<reference></reference>
</vuln_item_wasc_15>

<vuln_items>wasc_16</vuln_items>
<vuln_item_wasc_16>
	<alert>Direktoryo sa Pag-index</alert>
	<desc>Usa ka awtomatiko na direktoryo na paglista/pagindex sa usa ka web server na function na naglista sa tanan nga mga file na naa sa sulod sa gipangayo nga direktoryo kung ang normal base na file (index.html/home.html/default.htm/default.asp/default.aspx/index.php) kay wala diha. Sa dihang ang usa ka tiggamit kay hangyo sa pangunahing panid sa usa ka web site, sila kasagaran nagsulat sa usa ka URL sama sa: http://www.example.com/directory1/ - paggamit sa pangalan sa domain ug pagwalay labot sa usa ka espesipiko na file. Ang web server kay nagproseso sa hangyo niini ug nagpangita sa dokumento na root sa direktoryo para sa default na pangalan sa file ug nagpdala sa panid ngadto sa kliyente. Kung kining panid kay wala dinhi, ang web server kay naghinayhinay ug isyu sa usa ka listahan sa direktoryo ug nagpadala sa output ngadto sa kliyente. Pagkatinuod, kini kay pareha sa paghatag ug "ls" (Unix) o "dir" (Windows) na sugo sa sulod sa kini nga direktoryo ug nagpakita ug mga resulta sa HTML na form. Gikan sa usa ka pag-atake ug panglantaw sa countermeasure, kini kay importante na makaamgo nianang wala'y labot na mga listahan sa direktoryo mahimong posible tungod sa pagkahuyang sa software (gihisgutan sa panig-ingnan sa ubos na seksyon) inubanan sa usa ka piho nga paghangyo sa web.</desc>
	<solution>Mga rekomendasyon kay naglakip sa pagpugong sa pag-access sa mga importante na mga direktoryo o mga file pinaagi sa pagsagop sa panginahanglan nga mahibal-an na mga kinahanglanon para sa duha na dokumento ug server root, ug pagpatay sa mga bahin sama sa Awtomatik na Paglista sa mga Direktoryo nga mahimong ibutyag sa pribado nga mga file ug maghatag ug impormasyon nga mahimo gamiton sa usa ka tig-atake sa paghimo niini o pagdumala ug usa ka atake.</solution>
	<reference>http://projects.webappsec.org/Directory-Indexing</reference>
	<reference>http://cwe.mitre.org/data/definitions/548.html</reference>
</vuln_item_wasc_16>

<vuln_items>wasc_17</vuln_items>
<vuln_item_wasc_17>
	<alert>Dili sakto na Filesystem na mga Pagtugot</alert>
	<desc>Ang dili sakto nga filesystem na mga pagtugot kay usa ka hulga sa pagkakompidensyal, integridad ug pagkabaton ug usa ka web aplikasyon. Ang problema motindog kon sayop na filesystem na mga permiso kay natakda sa mga file, mga folder, ug mga symbolic link. Kun kanus-a ang dili sakto nga mga permiso kay gitakda, ang usa ka tig-atake kay mamahimong maka-access sa gilimitahan nga mga file o mga direktoryo ug pagbag-o o tangtangon ang ilang mga sulod. Pananglitan, kon ang usa ka wala mailhi nga tiggamit na account kay adunay pagsulat na permiso sa usa ka file, unya ang usa ka tig-atake kay makabag-o sa mga sulod sa file na nag-impluwensyasa web aplikasyon sa dili gusto nga mga pamaagi. Ang usa ka tig-atake kay mahimo usab na pahimuslan ang dili sakto na mga symlink para sa pagdako sa ilang mga pribilehiyo ug/o access sa dili awtorisado nga mga file; pananglitan, ang usa ka symlink nga nagtudlo sa usa ka direktoryo sa gawas sa web root.</desc>
	<solution>Maayo kaayo ang pagdumala sa setting, pagdumala ug pagdawat sa mga permiso. Tin-aw nga pagdumala sa mga pagsalig na dapit sa software.</solution>
	<reference>http://projects.webappsec.org/Improper-Filesystem-Permissions</reference>
	<reference>http://cwe.mitre.org/data/definitions/280.html</reference>
</vuln_item_wasc_17>

<vuln_items>wasc_18</vuln_items>
<vuln_item_wasc_18>
	<alert>Kredensyal ug Sesyon na Prediction</alert>
	<desc>Kredensiyal/Sesyon na Prediction kay usa ka pamaagi sa pag-hijack o pagsuon sa usa ka web site nga tiggamit. Pagbawas ug pagtagna sa talagsaong mga bili nga nagpaila sa usa ka partikular na sesyon o ang tiggamit nagatuman sa atake. Kini giila usab na Sesyon Hijacking, ang mga sangputanan kay mahimong sa mga tig-atake ug abilidad para i-isyu ang web site nga mga hangyo nga adunay nakompromiso na mga pribilehiyo sa tiggamit.

Daghan na mga web site kay gidesinyo sa pagpamatuod ug pagsubay sa usa ka tiggamit kung ang komunikasyon kay una natukod. Para himoon kini, ang mga tiggamit kay kailangan na pamatud-an ang iyang pagkatawo sa web site, na kasagaran ang pagbutang sa username/password (mga kredensyal) na mga kumbinasyon. Rather than passing these confidential credentials back and forth with each transaction, web sites will generate a unique "session ID" to identify the user session as authenticated. Subsequent communication between the user and the web site is tagged with the session ID as "proof" of the authenticated session. If an attacker is able predict or guess the session ID of another user, fraudulent activity is possible.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Credential-and-Session-Prediction</reference>
	<reference></reference>
</vuln_item_wasc_18>

<vuln_items>wasc_19</vuln_items>
<vuln_item_wasc_19>
	<alert>SQL indyeksyon</alert>
	<desc>Ang SQL indyeksyon kay usa ka teknik sa pag-atake na gigamit sa pagpahimulos sa mga aplikasyon na maghimo ug mga SQL na mga statement kinsa sa gipanghimo sa tiggamit. Kung magmalampuson, ang usa ka tig-atake kay pwedeng makahimo sa pag-usab sa lohika sa SQL nga mga statement na gipangbuhat batol sa database.

Ang Structured Query Language (SQL) kay usa ka espesyalista nga programming language para sa pagpadala sa mga query padung sa mga database. Ang SQL programming language kay mao ang duha na ANSI ug ang ISO na standard, bisan daghang mga database sa mga produkto nga nisuporta sa SQL buhata kini uban ang mga proprietary na mga extension ngadto sa standard na language. Ang mga aplikasyon kay kanunay nga gamitonsa gipangsulod na datos sa tiggamit ngato sa pagbuhat ug SQL na mga statement. Kung ang usa ka aplikasyon kay pakyas sa paghusto na pagbuhat sa SQL na mga statement na kini posible para sa usa ka tig-atake aron mausab ang ang istraktura sa statament ug buhaton ang wala planoha ug kalagmitan kontra nga mga sugo. Kung kana nga mga sugo kay napatuman, ila kining gibuhat sa ilalum sa kontekto sa usa ka bunggat sa tiggamitan pinaagi sa aplikasyon sa pagpatuman sa pahayag. Kini nga kapabilidad kay nagpatuman sa mga tig-atake na makakuha ug kontrol sa tanan nga database na mga kapanguhaan na ma-access sa maong tiggamitan, hangtod sa ug lakip na ang abilidad sa paghimo ug mga sugo sa nag-host na sistema.</desc>
	<solution>Hugna: Arkitektura ug Disenyo
Ang paggamit sa usa ka ibrarya nga na-vetted o balangkas nga dili motugot nga mahitabo kini nga kahuyang o maghatag og mga pagtukod nga makahimo niini nga kahuyang mas sayon ​​paglikay.
For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.

Kon anaa, gamiton ang structured na mga mekanismo para awtomatiko na mopatuman sa pagbulag sa datos ug sa code. Kini nga mga mekanismo kay makahimong makahatag sa may kalabutan nga pagkutlo, encoding, ug pagbalido nga awtomatiko, imbis nga mosalig sa developer sa paghatag niini nga kapabilidad sa matag punto nga diin ang output kay namugna.

Nagproseso ug SQL na mga query na naggamit sa giandam na mga statement, parameterized na mga query, o nagpasulod sa mga pamaagi. Kini nga mga bahin kay kinahanglan modawat ug mga parameter o mga variable ug pagsuporta sa kusog nga pag-type. Ayaw pagusab-usab sa gipangbuhat ug magpadagan sa query na mga string sa sulod sa mga bahin niini na gigamit ang "exec" o pareho nga katuyoan, tungod kay mahimo nimo nga ipaila-ila ang posibilidad sa SQL injection.

Padagana ang imong code na naggamit sa pinakaubos na mga pribilehiyo na nagkinahanglan sa paghuman sa kinahanglan na mga trabahoon. Kung posible, magbuhat ug nahilayo nga mga asoy nga adunay limitado nga mga pribilehiyo na gigamit lamang para sa usa ka solo nga buhatonon. Kana nga paagi. usa ka malampuson nga atake dili dayon makahatag sa tig-atake ug access sa tanan sa software o ka iyang environment. Pananglitan, ang database na mga aplikasyon kay panagsa nagkinahanglan sa pagpadagan nga ingon nga tagdumala sa database, ilabi na sa adlaw-adlaw nga mga operasyon.

Sa piho nga paagi, pagsubay sa prinsipyo sa pinakaubos na mga pribilehiyo kung nagnimo ug mga tiggamit na mga account ngadto sa SQL database. Ang mga tiggamit sa database kay dapat lang na adunay pinakagamay na mga pribilehiyo na nagkinahanglan sa paggamit sa iyang account. Kung ang mga kinahanglanon sa sistema nagpasabot nga usa ka tiggamit kay makabasa ug makailis sa ilang kaugalingon na datos, unya limitahan ang ilang mga pribilehiyo para sila dili maka basa/sulat sa laing mga datos. Gamita ang pinaka istrikto nga mga pagugot nga posible sa tanan nga mga butang sa database, sama sa pagpadagan lamang para sa mga stored na mga procedure.

Bahin: Pagpatuman
Kung ikaw nagkinahanglan na mogamit sa pagilisilis nga namugna sa query na mga string o mga sugo na bisan pa sa risgo, sakto na pag-quote sa mga argumento ug pag-ikyas sa bisag unsa na espesyal na mga karakter sa sulod sa maong mga argumento. Ang pinaka konserbatibo nga pagduol kay ang pag-ikyas sa sala sa tanan nga mga karakter na sila dili makaagi sa sobra nga pagka-istrikto na whitelist (sama sa tana na wala sa alphanumeric o mga puti na mga space). Kung ang uban na espesyal na mga karakter kay gikinahanglan gihapon, sama sa puti na space, na giputos ang matag argumento sa mga quote paghuman sa pag-ikyas/ug pagsala na lakang. Pag-amping sa argumento sa injection (CWE-88).

Hinunoa ang pagbuhat sa imong kaugalingon na implementasyon, kana nga mga bahin kay mahimo nga magamit sa database o sa programming language. Pananglitan, ang Oracle DBMS ASSERT na package kay pwede makatan-aw o magpatuman sa mga parameter na adunay piho nga mga property na makabuhat kanila nga dili kaayo mahuyang ngadto sa SQL injection. Para sa MySQL, ang mysql kay matuod na pag-ikyas sa string() API function kay magamit sa duha sa C ug sa PHP.

Hunahunaa nga ang tanan nga input kay malisyoso. Mogamit ug "dawata ang maayo nga nahibal-an" sa pagsulod sa pagbalido na estratehiya i.e., gamita ang usa ka whitelist sa mga madawat nga mga input nga estrikto nga subay sa mga paghingalan. Isalikway ang bisan unsang pagsulod nga dili hugot subay sa mga paghingalan, o na nag-usab kini sa bisag unsa nga gibuhat. Ayaw pagsalig lamang sa pagpangita sa mga malisyoso o sayop nga mga pagpasulod (pan., ayaw pagsalig sa blacklist). Bisan pa niini, ang mga blacklist kay mahimong mapuslanon para sa pagmatikod sa potensyal na mga atake o pagtino sa mga gipangsulod kay perteng pagkasayopa na sila nagkinahanglan nga isalikway dayon.

Sa paghimo sa pagpasulod na pagbalido, hunahunaa ang tanan nga kalabutan sa mga kabtangan, naglakip na sa gitas-on, tipo sa pagpasulod, ang bug-os nga lugway sa gipangdawat nga mga bili, nawala o sobra nga mga pagsulod, syntax, pagkamakanunayon sa tibuuk nga mga natad, ug pagpahiuyon sa mga lagda sa negosyo. Ingon sa pananglitan sa negosyo na lohika sa pagmando, "barko" kay mahimo nga syntactically na balido tungod kay kini naglangkob lamang sa alphanumeric na mga karakter, apan dili kini usa ka balido kung ikaw nagpaabot sa kolor na "pila" o "asul". Kini dili direkta nga maglimit sa ug ka scope sa usa ka atake, pero kini nga teknik ay dili kaayo importante kay sa tukmang pag-encode sa output ug pag-ikyas.

Timan-i nga angay ang output nga pag-encode, pag-ikyas ug pag-quote sa pinaka epektibo nga solusyon para pugngan ang SQL Injection, bisan pa sa pag-validate sa input mahimong mohatag og pipila ka depende sa nasa ilalom. Tungod kini epektibo sa paglimitar sa unsa ang gilauman sa output. Pag-validate sa sa pagpasulod kay dili permanente nga SQL injection, ilabi na kon gikinahanglan ug suporta sa usa ka libre nga porma sa teksyo sa mga field nga mahimong adunay usa ka na arbitraty sa mga karakter. Pananglitan, ang pangalan na "O'Reilly" na lagmit moagi sa pag-balido nga lakang, kay kini dili komon sa apelyedo sa English language. Bisan pa ni, dili kini mamahimong direkta nga pagpagsal-ot ngadto sa database tungod kay kini anaay sulod na "'" apostrophe na karakter nga gikinahanglan na mo-ikyas o kon dili nagunitan. Sa kaso niini, paghukas sa apostrophe kay mahimong makunhoran ang risgo sa SQL ina injection, apan kini naggahimo ug dili sakto nga kinaiya tungod kay sayop ang pangalan na madala unta.

Kung mahimo, kini mahimo nga labing luwas sa pagdili pagtugot sa meta-mga karakter sa kinatibuk-an, na hinoon sa pag-ikyas kanila. Kini kay paghatag og pipila ka mga depensa sa lawom. Paghuman ang datos nasudlan ug datos sa database, sa ulahi nga mga proseso kay mahimong magpasagad sa pag-ikyas sa meta-na mga karakter sa dili pa mogamit, ug ikaw kay posible na walay kontrol sa ibabaw niana nga mga proseso.</solution>
	<reference>http://projects.webappsec.org/SQL-Injection</reference>
	<reference></reference>
</vuln_item_wasc_19>

<vuln_items>wasc_20</vuln_items>
<vuln_item_wasc_20>
	<alert>Dili sakto nga pag-input na Pagkupot</alert>
	<desc>Ang dili sakto nga pag-input sa pagkupot sa usa sa pinaka komon na mga mahuyang gituohan nga tabok sa mga aplikasyon karon. Pobre nga pagkupot sa input kay mao ang nag-unang hinungdan sa likod sa kritikal na mga kahuyangan na anaaa sa mga sistema ug mga aplikasyon.
	
Sa kinatibuk-an, ang pulong na pag-input sa pagdumala kay gigamit para paghulagway sa mga gimbuhaton pareha sa pagbalido, pag-filter, pag-encode ug/o pag-decode sa input na datos. Mga aplikasyon kay nagdawat ug input gikan sa lainlain nga mga tinubdan lakip na ang tawo nga mga tiggamit, software na mga ahente (mga browser), ug network/peripheral na mga device para mopangalan sa pipila lang. In the case of web applications, input can be transferred in various formats (name value pairs, JSON, SOAP, etc...) and obtained via URL query strings, POST data, HTTP headers, Cookies, etc... Non-web application input can be obtained via application variables, environment variables, the registry, configuration files, etc... Regardless of the data format or source/location of the input, all input should be considered untrusted and potentially malicious. Applications which process untrusted input may become vulnerable to attacks such as Buffer Overflows, SQL Injection, OS Commanding, Denial of Service just to name a few.

One of the key aspects of input handling is validating that the input satisfies a certain criteria. For proper validation, it is important to identify the form and type of data that is acceptable and expected by the application. Defining an expected format and usage of each instance of untrusted input is required to accurately define restrictions. 

Validation can include checks for type safety and correct syntax. String input can be checked for length (min and max number of characters) and character set validation while numeric input types like integers and decimals can be validated against acceptable upper and lower bound of values. When combining input from multiple sources, validation should be performed during concatenation and not just against the individual data elements. This practice helps avoid situations where input validation may succeed when performed on individual data items but fails when done on a combined set from all the sources.</desc>
	<solution>Bahin: Arkitektura ug Disenyo

Gamita ang input input validation nga framework sama sa mga Strut o ang OWASP ESAPI Validation API.

Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Hinumdomi kana nga mga gipangsulod kay mahimong makaangkon ug dili diretso pinaagi sa API nga mga tawag.

For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side. Ang mga tig-atake kay mahimong maka-bypass sa bahin sa kliyente sa pag-usab sa mga bili paghuman sa pagtan-aw kung unsa na ang nabuhat, o pinaagi sa pagbag-o sa kliyente para matangtang ang bahin sa kliyente nga pangtan-aw sa kinatibuk-an. Dayon, kini nga mga gipangbag-o na mga bili, kay mahimong isumite sa server.

Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.

Do not rely exclusively on blacklist validation to detect malicious input or to encode output. There are too many ways to encode the same character, so you're likely to miss some variants.

When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.

Hunahunaa nga ang tanan nga input kay malisyoso. Mogamit ug "dawata ang maayo nga nahibal-an" sa pagsulod sa pagbalido na estratehiya i.e., gamita ang usa ka whitelist sa mga madawat nga mga input nga estrikto nga subay sa mga paghingalan. Isalikway ang bisan unsang pagsulod nga dili hugot subay sa mga paghingalan, o na nag-usab kini sa bisag unsa nga gibuhat. Ayaw pagsalig lamang sa pagpangita sa mga malisyoso o sayop nga mga pagpasulod (pan., ayaw pagsalig sa blacklist). Bisan pa niini, ang mga blacklist kay mahimong mapuslanon para sa pagmatikod sa potensyal na mga atake o pagtino sa mga gipangsulod kay perteng pagkasayopa na sila nagkinahanglan nga isalikway dayon.

Sa paghimo sa pagpasulod na pagbalido, hunahunaa ang tanan nga kalabutan sa mga kabtangan, naglakip na sa gitas-on, tipo sa pagpasulod, ang bug-os nga lugway sa gipangdawat nga mga bili, nawala o sobra nga mga pagsulod, syntax, pagkamakanunayon sa tibuuk nga mga natad, ug pagpahiuyon sa mga lagda sa negosyo. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as "red" or "blue."

Phase: Implementation

Be especially careful to validate your input when you invoke code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.

Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. Pagkatapos sa pagkakabig sa gipaabot nga tipo sa datos, siguroha nga ang gi-input na mga bili mahulog sulod sa gipaabot nga gidak-on sa gitugot na mga bili ug kana nga multi-field na mga pagkaporma kay gipadayon.

Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not inadvertently decode the same input twice. Such errors could be used to bypass whitelist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.

Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.

When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.</solution>
	<reference>http://projects.webappsec.org/Improper-Input-Handling</reference>
	<reference>http://cwe.mitre.org/data/definitions/89.html</reference>
</vuln_item_wasc_20>

<vuln_items>wasc_21</vuln_items>
<vuln_item_wasc_21>
	<alert>Dili igo nga Anti awtomasyon</alert>
	<desc>Insufficient Anti-automation occurs when a web application permits an attacker to automate a process that was originally designed to be performed only in a manual fashion, i.e. by a human web user.

Web application functionality that is often a target for automation attacks may include:
    * Application login forms – attackers may automate brute force login requests in an attempt to guess user credentials
    * Service registration forms – attackers may automatically create thousands of new accounts
    * Email forms – attackers may exploit email forms as spam relays or for flooding a certain user’s mailbox
    * Account maintenance – attackers may perform mass DoS against an application, by flooding it with numerous requests to disable or delete user accounts
    * Account information forms – attackers may perform mass attempts to harvest user personal information from a web application
    * Comment forms / Content Submission forms – these may be used for spamming blogs, web forums and web bulletin boards by automatically submitting contents such as spam or even web-based malware
    * Forms tied to SQL database queries - these may be exploited in order to perform a denial of service attack against the application. The attack is performed by sending numerous heavy SQL queries in a short period of time, hence denying real users from service.
    * eShopping / eCommerce - eShopping and eCommerce applications that do not enforce human-only buyers, can be exploited in order to buy preferred items in large amounts, such as sporting events tickets. These are later sold by scalpers for higher prices.
    * Online polls - polls and other types of online voting systems can be automatically subverted in favor of a certain choice.
    * Web-based SMS message sending - attackers may exploit SMS message sending systems in order to spam mobile phone users
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insufficient+Anti-automation</reference>
	<reference>http://cwe.mitre.org/data/definitions/116.html</reference>
</vuln_item_wasc_21>

<vuln_items>wasc_22</vuln_items>
<vuln_item_wasc_22>
	<alert>Dili sakto nga Output na Pagkupot</alert>
	<desc>Output handling refers to how an application generates outgoing data.  If an application has improper output handling, the output data may be consumed leading to vulnerabilities and actions never intended by the application developer.  In many cases, this unintended interpretation is classified as one or more forms of critical application vulnerabilities.

Any location where data leaves an application boundary may be subject to improper output handling.  Application boundaries exist where data leaves one context and enters another.  This includes applications passing data to other applications via web services, sockets, command line, environmental variables, etc...  It also includes passing data between tiers within an application architecture, such as a database, directory server, HTML/JavaScript interpreter (browser), or operating system.  More detail on where improper output handling can occur can be found in the section below titled "Common Data Output Locations”.

Improper output handling may take various forms within an application.  These forms can be categorized into: protocol errors, application errors and data consumer related errors.  Protocol errors include missing or improper output encoding or escaping and outputting of invalid data.  Application errors include logic errors such as outputting incorrect data or passing on malicious content unfiltered.  If the application does not properly distinguish legitimate content from illegitimate, or does not work around known vulnerabilities in the data consumer, it may result in data-consumer abuse caused from improper output handling.

An application that does not provide data in the correct context may allow an attacker to abuse the data consumer.  This can lead to specific threats referenced within the WASC Threat Classification, including Content Spoofing, Cross-Site Scripting, HTTP Response Splitting, HTTP Response Smuggling, LDAP Injection, OS Commanding, Routing Detour, Soap Array Abuse, URL Redirector, XML Injection, XQuery Injection, XPath Injection, Mail Command Injection, Null Injection and SQL Injection.

Proper output handling prevents the unexpected or unintended interpretation of data by the consumer.  To achieve this objective, developers must understand the application's data model, how the data will be consumed by other portions of the application, and how it will ultimately be presented to the user.  Techniques for ensuring the proper handling of output include but are not limited to the filtering and sanitization of data (more detail on output sanitization and filtering can be found in appropriately titled sections below).  However, inconsistent use of selected output handling techniques may actually increase the risk of improper output handling if output data is overlooked or left untreated.  To ensure "defense in depth" developers must assume that all data within an application is untrusted when choosing appropriate output handling strategies.

While proper output handling may take many different forms, an application cannot be secure unless it protects against unintended interpretations by the data consumer. This core requirement is essential for an application to securely handle output operations.</desc>
	<solution>Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.

For example, consider using the ESAPI Encoding control or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.

Alternately, use built-in functions, but consider using wrappers in case those functions are discovered to have a vulnerability.

Kon anaa, gamiton ang structured na mga mekanismo para awtomatiko na mopatuman sa pagbulag sa datos ug sa code. Kini nga mga mekanismo kay makahimong makahatag sa may kalabutan nga pagkutlo, encoding, ug pagbalido nga awtomatiko, imbis nga mosalig sa developer sa paghatag niini nga kapabilidad sa matag punto nga diin ang output kay namugna.

For example, stored procedures can enforce database query structure and reduce the likelihood of SQL injection.

Understand the context in which your data will be used and the encoding that will be expected. Kini kay ilabi ka importante kon magpadala ug datos nga tali sa nagkalainglaing mga komponent, o sa diha nga pagmugna sa mga output nga mahimong adunay sunod na daghang mga encoding na sa samang higayon, sama sa mga web page o o multi-part mail na mga mensahe. Pagtuon sa tanan kay gilauman na mga protocol sa komunikasyon ug representasyon sa datos sa pagtino sa kinahanglan ang encoding na mga estratehiya.

In some cases, input validation may be an important strategy when output encoding is not a complete solution. For example, you may be providing the same output that will be processed by multiple consumers that use different encodings or representations. In other cases, you may be required to allow user-supplied input to contain control information, such as limited HTML tags that support formatting in a wiki or bulletin board. When this type of requirement must be met, use an extremely strict whitelist to limit which control sequences can be used. Verify that the resulting syntactic structure is what you expect. Use your normal encoding methods for the remainder of the input.

Use input validation as a defense-in-depth measure to reduce the likelihood of output encoding errors (see CWE-20).

When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.</solution>
	<reference>http://projects.webappsec.org/Improper-Output-Handling</reference>
	<reference></reference>
</vuln_item_wasc_22>

<vuln_items>wasc_23</vuln_items>
<vuln_item_wasc_23>
	<alert>XML Injection</alert>
	<desc>XML Injection is an attack technique used to manipulate or compromise the logic of an XML application or service. The injection of unintended XML content and/or structures into an XML message can alter the intend logic of the application. Further, XML injection can cause the insertion of malicious content into the resulting message/document.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/XML-Injection</reference>
	<reference></reference>
</vuln_item_wasc_23>

<vuln_items>wasc_24</vuln_items>
<vuln_item_wasc_24>
	<alert>HTTP Request Splitting</alert>
	<desc>HTTP Request Splitting is an attack that enables forcing the browser to send arbitrary HTTP requests, inflicting XSS and poisoning the browser's cache. The essence of the attack is the ability of the attacker, once the victim (browser) is forced to load the attacker's malicious HTML page, to manipulate one of the browser's functions to send 2 HTTP requests instead of one HTTP request. Two such mechanisms have been exploited to date: the XmlHttpRequest object (XHR for short) and the HTTP digest authentication mechanism. For this attack to work, the browser must use a forward HTTP proxy (not all of them "support" this attack), or the attack must be carried out against a host located on the same IP (from the browser's perspective) with the attacker's machine.</desc>
	<solution>Avoid using CRLF as a special sequence.

Appropriately filter or quote CRLF sequences in user-controlled input.</solution>
	<reference>http://projects.webappsec.org/HTTP-Request-Splitting</reference>
	<reference>http://cwe.mitre.org/data/definitions/93.html</reference>
</vuln_item_wasc_24>

<vuln_items>wasc_25</vuln_items>
<vuln_item_wasc_25>
	<alert>HTTP Response Splitting</alert>
	<desc>In the HTTP Response Splitting attack, there are always 3 parties (at least) involved:
    * Web server, which has a security hole enabling HTTP Response Splitting
    * Target - an entity that interacts with the web server perhaps on behalf of the attacker. Typically this is a cache server forward/reverse proxy), or a browser (possibly with a browser cache).
    * Attacker - initiates the attack

The essence of HTTP Response Splitting is the attacker's ability to send a single HTTP request that forces the web server to form an output stream, which is then interpreted by the target as two HTTP responses instead of one response, in the normal case. The first response may be partially controlled by the attacker, but this is less important. What is material is that the attacker completely controls the form of the second response from the HTTP status line to the last byte of the HTTP response body. Once this is possible, the attacker realizes the attack by sending two requests through the target. The first one invokes two responses from the web server, and the second request would typically be to some "innocent" resource on the web server. However, the second request would be matched, by the target, to the second HTTP response, which is fully controlled by the attacker. The attacker, therefore, tricks the target into believing that a particular resource on the web server (designated by the second request) is the server's HTTP response (server content), while it is in fact some data, which is forged by the attacker through the web server - this is the second response.

HTTP Response Splitting attacks take place where the server script embeds user data in HTTP response headers. This typically happens when the script embeds user data in the redirection URL of a redirection response (HTTP status code 3xx), or when the script embeds user data in a cookie value or name when the response sets a cookie.</desc>
	<solution>Construct HTTP headers very carefully, avoiding the use of non-validated input data.</solution>
	<reference>http://projects.webappsec.org/HTTP-Response-Splitting</reference>
	<reference>http://cwe.mitre.org/data/definitions/113.html</reference>
</vuln_item_wasc_25>

<vuln_items>wasc_26</vuln_items>
<vuln_item_wasc_26>
	<alert>HTTP Request Smuggling</alert>
	<desc>HTTP Request Smuggling is an attack technique that abuses the discrepancy in parsing of non RFC compliant HTTP requests between two HTTP devices (typically a front-end proxy or HTTP-enabled firewall and a back-end web server) to smuggle a request to the second device "through" the first device. This technique enables the attacker to send one set of requests to the second device while the first device sees a different set of requests. In turn, this facilitates several possible exploitations, such as partial cache poisoning, bypassing firewall protection and XSS.</desc>
	<solution>Use a web server that employs a strict HTTP parsing procedure, such as Apache (See paper in reference).

Use only SSL communication.

Terminate the client session after each request.

Turn all pages to non-cacheable.</solution>
	<reference>http://projects.webappsec.org/HTTP-Request-Smuggling</reference>
	<reference>http://cwe.mitre.org/data/definitions/444.html</reference>
</vuln_item_wasc_26>

<vuln_items>wasc_27</vuln_items>
<vuln_item_wasc_27>
	<alert>HTTP Response Smuggling</alert>
	<desc>HTTP response smuggling is a technique to "smuggle" 2 HTTP responses from a server to a client, through an intermediary HTTP device that expects (or allows) a single response from the server.

One use for this technique is to enhance the basic HTTP response splitting technique in order to evade anti- HTTP response splitting measures. In this case, the intermediary is the anti-HTTP response splitting mechanism between the web server and the proxy server (or web browser). Another use case is to spoof responses received by the browser. In this case a malicious web site serves the browser a page that the browser will interpret as originating from a different (target) domain. HTTP response smuggling can be used to achieve this when the browser uses a proxy server to access both sites.

HTTP response smuggling makes use of HTTP request smuggling -like techniques to exploit the discrepancies between what an anti- HTTP Response Splitting mechanism (or a proxy server) would consider to be the HTTP response stream, and the response stream as parsed by a proxy server (or a browser). So, while an anti- HTTP response splitting mechanism may consider a particular response stream harmless (single HTTP response), a proxy/browser may still parse it as two HTTP responses, and hence be susceptible to all the outcomes of the original HTTP response splitting technique (in the first use case) or be susceptible to page spoofing (in the second case). For example, some anti- HTTP response splitting mechanisms in use by some application engines forbid the application from inserting a header containing CR+LF to the response. Yet an attacker can force the application to insert a header containing CRs, thereby circumventing the defense mechanism. Some proxy servers may still treat CR (only) as a header (and response) separator, and as such the combination of web server and proxy server will still be vulnerable to an attack that may poison the proxy's cache.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/HTTP-Response-Smuggling</reference>
	<reference></reference>
</vuln_item_wasc_27>

<vuln_items>wasc_28</vuln_items>
<vuln_item_wasc_28>
	<alert>Null Byte Injection</alert>
	<desc>Null Byte Injection is an active exploitation technique used to bypass sanity checking filters in web infrastructure by adding URL-encoded null byte characters (i.e. %00, or 0x00 in hex) to the user-supplied data. This injection process can alter the intended logic of the application and allow malicious adversary to get unauthorized access to the system files.

Most web applications today are developed using higher-level languages such as, PHP, ASP, Perl, and Java. However, these web applications at some point require processing of high-level code at system level and this process is usually accomplished by using ‘C/C++’ functions. The diverse nature of these dependent technologies has resulted in an attack class called ‘Null Byte Injection’ or ‘Null Byte Poisoning’ attack. In C/C++, a null byte represents the string termination point or delimiter character which means to stop processing the string immediately. Bytes following the delimiter will be ignored. If the string loses its null character, the length of a string becomes unknown until memory pointer happens to meet next zero byte. This unintended ramification can cause unusual behavior and introduce vulnerabilities within the system or application scope. In similar terms, several higher-level languages treat the ‘null byte’ as a placeholder for the string length as it has no special meaning in their context. Due to this difference in interpretation, null bytes can easily be injected to manipulate the application behavior.

URLs are limited to a set of US-ASCII characters ranging from 0x20 to 0x7E (hex) or 32 to 126 (decimal). However, the aforementioned range uses several characters that are not permitted because they have special meaning within HTTP protocol context. For this reason, the URL encoding scheme was introduced to include special characters within URL using the extended ASCII character representation. In terms of “null byte”, this is represented as %00 in hexadecimal. The scope of a null byte attack starts where web applications interact with active ‘C’ routines and external APIs from the underlying OS. Thus, allowing an attacker to manipulate web resources by reading or writing files based on the application's user privileges.</desc>
	<solution>Developers should anticipate that null characters or null bytes will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and white lists to ensure only valid, expected and appropriate input is processed by the system.

Hunahunaa nga ang tanan nga input kay malisyoso. Use a standard input validation mechanism to validate all input for length, type, syntax, and business rules before accepting the data to be displayed or stored. Use an "accept known good" validation strategy.

Use and specify a strong output encoding (such as ISO 8859-1 or UTF 8).

Do not rely exclusively on blacklist validation to detect malicious input or to encode output. There are too many variants to encode a character; you're likely to miss some variants.

Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not decode the same input twice. Such errors could be used to bypass whitelist schemes by introducing dangerous inputs after they have been checked.</solution>
	<reference>http://projects.webappsec.org/Null-Byte-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/158.html</reference>
</vuln_item_wasc_28>

<vuln_items>wasc_29</vuln_items>
<vuln_item_wasc_29>
	<alert>LDAP Injection</alert>
	<desc>LDAP Injection is an attack technique used to exploit web sites that construct LDAP statements from user-supplied input.

Lightweight Directory Access Protocol (LDAP) is an open-standard protocol for both querying and manipulating X.500 directory services. The LDAP protocol runs over Internet transport protocols, such as TCP. Web applications may use user-supplied input to create custom LDAP statements for dynamic web page requests.

When a web application fails to properly sanitize user-supplied input, it is possible for an attacker to alter the construction of an LDAP statement. When an attacker is able to modify an LDAP statement, the process will run with the same permissions as the component that executed the command. (e.g. Database server, Web application server, Web server, etc.). This can cause serious security problems where the permissions grant the rights to query, modify or remove anything inside the LDAP tree. The same advanced exploitation techniques available in SQL Injection can also be similarly applied in LDAP Injection.</desc>
	<solution>Hunahunaa ang tanan nga input kay malisyoso. Gamitan ang usa ka saktong kumbinasyon sa mga black list ug mga white list para pag-neutralize sa LDAP syntax gikan sa input nga gikontrol sa tiggamit.</solution>
	<reference>http://projects.webappsec.org/LDAP-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/90.html</reference>
</vuln_item_wasc_29>

<vuln_items>wasc_30</vuln_items>
<vuln_item_wasc_30>
	<alert>Mail Command Injection</alert>
	<desc>Mail Command Injection is an attack technique used to exploit mail servers and webmail applications that construct IMAP/SMTP statements from user-supplied input that is not properly sanitized. Depending on the type of statement taken advantage by the attacker, we meet two types of injections: IMAP and SMTP Injection. An IMAP/SMTP Injection may make it possible to access a mail server which you previously had no access to before-hand. In some cases, these internal systems do not have the same level of infrastructure security hardening applied to them as most front-end web servers. Hence, attackers may find that the mail server yields better results in terms of exploitation. On the other hand, this technique allows to evade possible restrictions that could exist at application level (CAPTCHA, maximum number of requests, etc.).</desc>
	<solution>Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, request headers as well as content, URL components, e-mail, files, databases, and any external systems that provide data to the application. Perform input validation at well-defined interfaces.

Hunahunaa nga ang tanan nga input kay malisyoso. Use an "accept known good" input validation strategy (i.e., use a whitelist). Isalikway ang bisan unsang pagsulod nga dili hugot subay sa mga paghingalan, o na nag-usab kini sa bisag unsa nga gibuhat. Use a blacklist to reject any unexpected inputs and detect potential attacks.

Do not rely exclusively on blacklist validation to detect malicious input or to encode output. There are too many ways to encode the same character, so you're likely to miss some variants.

Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. Pagkatapos sa pagkakabig sa gipaabot nga tipo sa datos, siguroha nga ang gi-input na mga bili mahulog sulod sa gipaabot nga gidak-on sa gitugot na mga bili ug kana nga multi-field na mga pagkaporma kay gipadayon.

Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not inadvertently decode the same input twice . Such errors could be used to bypass whitelist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.

Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.

When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.

When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.</solution>
	<reference>http://projects.webappsec.org/Mail-Command-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/88.html</reference>
</vuln_item_wasc_30>

<vuln_items>wasc_31</vuln_items>
<vuln_item_wasc_31>
	<alert>OS Commanding</alert>
	<desc>OS Commanding is an attack technique used for unauthorized execution of operating system commands.

OS Commanding is the direct result of mixing trusted code and untrusted data. This attack is possible when an application accepts untrusted input to build operating system commands in an insecure manner involving improper data sanitization, and/or improper calling of external programs. In OS Commanding, executed commands by an attacker will run with the same privileges of the component that executed the command, (e.g. database server, web application server, web server, wrapper, application). Since the commands are executed under the privileges of the executing component an attacker can leverage this to gain access or damage parts that are otherwise unreachable (e.g. the operating system directories and files).</desc>
	<solution>If at all possible, use library calls rather than external processes to recreate the desired functionality.

Run your code in a "jail" or similar sandbox environment that enforces strict boundaries between the process and the operating system. Mahimo kini nga epektibong nga pugngan kung asa ang mga file kay mahimong makasulod sa usa ka ilabing direktoryo o ang mga gipangsugo kay pwedeng mapadagan sa imong software.

Ang OS nga lebel nga mga pananglitan kay naglakip sa Unix chroot jail, AppArmor, ug SELinux. Sa kinatibuk-an, ang gipadumala nga code kay mahimong mohatag ug dugang proteksyon. Pananglitan ang java.io.FilePermission sa diha nga Java SecurityManager nga nagtugot sa imoha sa pagtakda sa mga gipangdili sa file na mga operasyon.
Kini dili mahimo nga solusyon, ug kini lamang naglimit sa epekto sa operating system; ug uban pa sa imong aplikasyon kay mahimong magpasakop gihapon aron makompromiso.

For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the command locally in the session's state instead of sending it out to the client in a hidden form field.

Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.

For example, consider using the ESAPI Encoding control or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.

If you need to use dynamically-generated query strings or commands in spite of the risk, properly quote arguments and escape any special characters within those arguments. Ang pinaka konserbatibo nga pagduol kay ang pag-ikyas sa sala sa tanan nga mga karakter na sila dili makaagi sa sobra nga pagka-istrikto na whitelist (sama sa tana na wala sa alphanumeric o mga puti na mga space). Kung ang uban na espesyal na mga karakter kay gikinahanglan gihapon, sama sa puti na space, na giputos ang matag argumento sa mga quote paghuman sa pag-ikyas/ug pagsala na lakang. Be careful of argument injection.

If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.

Kon anaa, gamiton ang structured na mga mekanismo para awtomatiko na mopatuman sa pagbulag sa datos ug sa code. Kini nga mga mekanismo kay makahimong makahatag sa may kalabutan nga pagkutlo, encoding, ug pagbalido nga awtomatiko, imbis nga mosalig sa developer sa paghatag niini nga kapabilidad sa matag punto nga diin ang output kay namugna.

Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.

Hunahunaa nga ang tanan nga input kay malisyoso. Mogamit ug "dawata ang maayo nga nahibal-an" sa pagsulod sa pagbalido na estratehiya i.e., gamita ang usa ka whitelist sa mga madawat nga mga input nga estrikto nga subay sa mga paghingalan. Isalikway ang bisan unsang pagsulod nga dili hugot subay sa mga paghingalan, o na nag-usab kini sa bisag unsa nga gibuhat. Ayaw pagsalig lamang sa pagpangita sa mga malisyoso o sayop nga mga pagpasulod (pan., ayaw pagsalig sa blacklist). Bisan pa niini, ang mga blacklist kay mahimong mapuslanon para sa pagmatikod sa potensyal na mga atake o pagtino sa mga gipangsulod kay perteng pagkasayopa na sila nagkinahanglan nga isalikway dayon.

Sa paghimo sa pagpasulod na pagbalido, hunahunaa ang tanan nga kalabutan sa mga kabtangan, naglakip na sa gitas-on, tipo sa pagpasulod, ang bug-os nga lugway sa gipangdawat nga mga bili, nawala o sobra nga mga pagsulod, syntax, pagkamakanunayon sa tibuuk nga mga natad, ug pagpahiuyon sa mga lagda sa negosyo. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as "red" or "blue."

When constructing OS command strings, use stringent whitelists that limit the character set based on the expected value of the parameter in the request. Kini dili direkta nga maglimit sa ug ka scope sa usa ka atake, pero kini nga teknik ay dili kaayo importante kay sa tukmang pag-encode sa output ug pag-ikyas.

Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. Tungod kini epektibo sa paglimitar sa unsa ang gilauman sa output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like ";" and ">" characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components.

Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.</solution>
	<reference>http://projects.webappsec.org/OS-Commanding</reference>
	<reference>http://cwe.mitre.org/data/definitions/78.html</reference>
</vuln_item_wasc_31>

<vuln_items>wasc_32</vuln_items>
<vuln_item_wasc_32>
	<alert>Routing Detour</alert>
	<desc>The WS-Routing Protocol (WS-Routing) is a protocol for exchanging SOAP messages from an initial message sender to an ultimate receiver, typically via a set of intermediaries. The WS-Routing protocol is implemented as a SOAP extension, and is embedded in the SOAP Header. WS-Routing is often used to provide a way to direct XML traffic through complex environments and transactions by allowing interim way stations in the XML path to assign routing instructions to an XML document.

Routing Detours are a type of "Man in the Middle" attack where Intermediaries can be injected or "hijacked" to route sensitive messages to an outside location. Routing information (either in the HTTP header or in WS-Routing header) can be modified en route and traces of the routing can be removed from the header and message such that the receiving application none the wiser that a routing detour has occurred. The header and the insertion of header objects is often less protected than the message; this is due to the fact that the header is used as a catch all for metadata about the transaction such as authentication, routing, formatting, schema, canonicalization, namespaces, etc. Also, many processes may be involved in adding to/processing the header of an XML document. In many implementations the routing info can come from an external web service (using WS-Referral for example) that provides the specific routing for the transaction.

WS-Addressing is a newer standard published by the W3C to provide routing functionality to SOAP messages. One of the key differences between WS-Routing and WS-Addressing is that WS-Addressing only provides the next location in the route. While little research has been done into the susceptibility of WS-Addressing to Routing Detour Attack, at least one paper (see reference #6 below) suggests that WS-Addressing is vulnerable to Routing Detour as well.</desc>
	<solution>Always fully authenticate both ends of any communications channel.

Adhere to the principle of complete mediation.

A certificate binds an identity to a cryptographic key to authenticate a communicating party. Often, the certificate takes the encrypted form of the hash of the identity of the subject, the public key, and information such as time of issue or expiration using the issuer's private key. The certificate can be validated by deciphering the certificate with the issuer's public key. See also X.509 certificate signature chains and the PGP certification structure.</solution>
	<reference>http://projects.webappsec.org/Routing-Detour</reference>
	<reference>http://cwe.mitre.org/data/definitions/300.html</reference>
</vuln_item_wasc_32>

<vuln_items>wasc_33</vuln_items>
<vuln_item_wasc_33>
	<alert>Path Traversal</alert>
	<desc>The Path Traversal attack technique allows an attacker access to files, directories, and commands that potentially reside outside the web document root directory. An attacker may manipulate a URL in such a way that the web site will execute or reveal the contents of arbitrary files anywhere on the web server. Any device that exposes an HTTP-based interface is potentially vulnerable to Path Traversal.

Most web sites restrict user access to a specific portion of the file-system, typically called the "web document root" or "CGI root" directory. These directories contain the files intended for user access and the executable necessary to drive web application functionality. To access files or execute commands anywhere on the file-system, Path Traversal attacks will utilize the ability of special-characters sequences.

The most basic Path Traversal attack uses the "../" special-character sequence to alter the resource location requested in the URL. Although most popular web servers will prevent this technique from escaping the web document root, alternate encodings of the "../" sequence may help bypass the security filters. These method variations include valid and invalid Unicode-encoding ("..%u2216" or "..%c0%af") of the forward slash character, backslash characters ("..\") on Windows-based servers, URL encoded characters "%2e%2e%2f"), and double URL encoding ("..%255c") of the backslash character.

Even if the web server properly restricts Path Traversal attempts in the URL path, a web application itself may still be vulnerable due to improper handling of user-supplied input. This is a common problem of web applications that use template mechanisms or load static text from files. In variations of the attack, the original URL parameter value is substituted with the file name of one of the web application's dynamic scripts. Consequently, the results can reveal source code because the file is interpreted as text instead of an executable script. These techniques often employ additional special characters such as the dot (".") to reveal the listing of the current working directory, or "%00" NULL characters in order to bypass rudimentary file extension checks.</desc>
	<solution>Hunahunaa nga ang tanan nga input kay malisyoso. Mogamit ug "dawata ang maayo nga nahibal-an" sa pagsulod sa pagbalido na estratehiya i.e., gamita ang usa ka whitelist sa mga madawat nga mga input nga estrikto nga subay sa mga paghingalan. Isalikway ang bisan unsang pagsulod nga dili hugot subay sa mga paghingalan, o na nag-usab kini sa bisag unsa nga gibuhat. Ayaw pagsalig lamang sa pagpangita sa mga malisyoso o sayop nga mga pagpasulod (pan., ayaw pagsalig sa blacklist). Bisan pa niini, ang mga blacklist kay mahimong mapuslanon para sa pagmatikod sa potensyal na mga atake o pagtino sa mga gipangsulod kay perteng pagkasayopa na sila nagkinahanglan nga isalikway dayon.

Sa paghimo sa pagpasulod na pagbalido, hunahunaa ang tanan nga kalabutan sa mga kabtangan, naglakip na sa gitas-on, tipo sa pagpasulod, ang bug-os nga lugway sa gipangdawat nga mga bili, nawala o sobra nga mga pagsulod, syntax, pagkamakanunayon sa tibuuk nga mga natad, ug pagpahiuyon sa mga lagda sa negosyo. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as "red" or "blue."

For filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single "." character in the filename to avoid weaknesses, and exclude directory separators such as "/". Use a whitelist of allowable file extensions.

Warning: if you attempt to cleanse your data, then do so that the end result is not in the form that can be dangerous. A sanitizing mechanism can remove characters such as '.' and ';' which may be required for some exploits. An attacker can try to fool the sanitizing mechanism into "cleaning" data into a dangerous form. Suppose the attacker injects a '.' inside a filename (e.g. "sensi.tiveFile") and the sanitizing mechanism removes the character resulting in the valid filename, "sensitiveFile". If the input data are now assumed to be safe, then the file may be compromised. 

Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not decode the same input twice. Such errors could be used to bypass whitelist schemes by introducing dangerous inputs after they have been checked.

Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes ".." sequences and symbolic links.

Padagana ang imong code na naggamit sa pinakaubos na mga pribilehiyo na nagkinahanglan sa paghuman sa kinahanglan na mga trabahoon. Kung posible, magbuhat ug nahilayo nga mga asoy nga adunay limitado nga mga pribilehiyo na gigamit lamang para sa usa ka solo nga buhatonon. Kana nga paagi. usa ka malampuson nga atake dili dayon makahatag sa tig-atake ug access sa tanan sa software o ka iyang environment. Pananglitan, ang database na mga aplikasyon kay panagsa nagkinahanglan sa pagpadagan nga ingon nga tagdumala sa database, ilabi na sa adlaw-adlaw nga mga operasyon.

When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

Run your code in a "jail" or similar sandbox environment that enforces strict boundaries between the process and the operating system. Mahimo kini nga epektibong nga pugngan kung asa ang mga file kay mahimong makasulod sa usa ka ilabing direktoryo o ang mga gipangsugo kay pwedeng mapadagan sa imong software.

Ang OS nga lebel nga mga pananglitan kay naglakip sa Unix chroot jail, AppArmor, ug SELinux. Sa kinatibuk-an, ang gipadumala nga code kay mahimong mohatag ug dugang proteksyon. Pananglitan ang java.io.FilePermission sa diha nga Java SecurityManager nga nagtugot sa imoha sa pagtakda sa mga gipangdili sa file na mga operasyon.

Kini dili mahimo nga solusyon, ug kini lamang naglimit sa epekto sa operating system; ug uban pa sa imong aplikasyon kay mahimong magpasakop gihapon aron makompromiso.
</solution>
	<reference>http://projects.webappsec.org/Path-Traversal</reference>
	<reference>http://cwe.mitre.org/data/definitions/22.html</reference>
</vuln_item_wasc_33>

<vuln_items>wasc_34</vuln_items>
<vuln_item_wasc_34>
	<alert>Predictable Resource Location</alert>
	<desc>Predictable Resource Location is an attack technique used to uncover hidden web site content and functionality. By making educated guesses via brute forcing an attacker can guess file and directory names not intended for public viewing. Brute forcing filenames is easy because files/paths often have common naming convention and reside in standard locations. These can include temporary files, backup files, logs, administrative site sections, configuration files, demo applications, and sample files. These files may disclose sensitive information about the website, web application internals, database information, passwords, machine names, file paths to other sensitive areas, etc...

This will not only assist with identifying site surface which may lead to additional site vulnerabilities, but also may disclose valuable information to an attacker about the environment or its users. Predictable Resource Location is also known as Forced Browsing, Forceful Browsing, File Enumeration, and Directory Enumeration.</desc>
	<solution>Apply appropriate access control authorizations for each access to all restricted URLs, scripts or files.

Consider using MVC based frameworks such as Struts.</solution>
	<reference>http://projects.webappsec.org/Predictable-Resource-Location</reference>
	<reference>http://cwe.mitre.org/data/definitions/425.html</reference>
</vuln_item_wasc_34>

<vuln_items>wasc_35</vuln_items>
<vuln_item_wasc_35>
	<alert>SOAP Array Abuse</alert>
	<desc>XML SOAP arrays are a common target for malicious abuse. SOAP arrays are defined as having a type of "SOAP-ENC:Array" or a type derived there from. SOAP arrays have one or more dimensions (rank) whose members are distinguished by ordinal position. An array value is represented as a series of elements reflecting the array, with members appearing in ascending ordinal sequence. For multi-dimensional arrays the dimension on the right side varies most rapidly. Each member element is named as an independent element. A web-service that expects an array can be the target of a XML DoS attack by forcing the SOAP server to build a huge array in the machine's memory, thus inflicting a DoS condition on the machine due to the memory pre-allocation.</desc>
	<solution> Perform adequate input validation against any value that influences the amount of memory that is allocated. Define an appropriate strategy for handling requests that exceed the limit, and consider supporting a configuration option so that the administrator can extend the amount of memory to be used if necessary.

Run your program using system-provided resource limits for memory. This might still cause the program to crash or exit, but the impact to the rest of the system will be minimized.</solution>
	<reference>http://projects.webappsec.org/SOAP-Array-Abuse</reference>
	<reference>http://cwe.mitre.org/data/definitions/789.html</reference>
</vuln_item_wasc_35>

<vuln_items>wasc_36</vuln_items>
<vuln_item_wasc_36>
	<alert>SSI Injection</alert>
	<desc>SSI Injection (Server-side Include) is a server-side exploit technique that allows an attacker to send code into a web application, which will later be executed locally by the web server. SSI Injection exploits a web application's failure to sanitize user-supplied data before they are inserted into a server-side interpreted HTML file.

Before serving an HTML web page, a web server may parse and execute Server-side Include statements before providing it to the client. In some cases (e.g. message boards, guest books, or content management systems), a web application will insert user-supplied data into the source of a web page.

If an attacker submits a Server-side Include statement, he may have the ability to execute arbitrary operating system commands, or include a restricted file's contents the next time the page is served. This is performed at the permission level of the web server user.</desc>
	<solution>Disable SSI execution on pages that do not require it. For pages requiring SSI ensure that you perform the following checks
- Only enable the SSI directives that are needed for this page and disable all others.
- HTML entity encode user supplied data before passing it to a page with SSI execution permissions.
- Use SUExec to have the page execute as the owner of the file instead of the web server user.</solution>
	<reference>http://projects.webappsec.org/SSI-Injection</reference>
	<reference></reference>
</vuln_item_wasc_36>

<vuln_items>wasc_37</vuln_items>
<vuln_item_wasc_37>
	<alert>Session Fixation</alert>
	<desc>Session Fixation is an attack technique that forces a user's session ID to an explicit value. Depende sa katuyoan sa target na web site, ang numero sa mga teknik kay pwede magamit para "ayuhon" ang sesyon ID nga bili. Kini nga mga teknik nga gidak-on gikan sa Cross-site Scripting kay nagpahimulos sa peppering sa web site na adunay karaan nga gibuhat na HTTP nga mga hangyo. After a user's session ID has been fixed, the attacker will wait for that user to login. Once the user does so, the attacker uses the predefined session ID value to assume the same online identity.

Generally speaking there are two types of session management systems when it comes to ID values. The first type is "permissive" systems that allow web browsers to specify any ID. The second type is "strict" systems that only accept server-side-generated values. With permissive systems, arbitrary session IDs are maintained without contact with the web site. Strict systems require the attacker to maintain the "trap-session", with periodic web site contact, preventing inactivity timeouts.

Without active protection against Session Fixation, the attack can be mounted against any web site that uses sessions to identify authenticated users. Web sites using sessions IDs are normally cookie-based, but URLs and hidden form fields are used as well. Unfortunately, cookie-based sessions are the easiest to attack. Most of the currently identified attack methods are aimed toward the fixation of cookies.

In contrast to stealing a users' session IDs after they have logged into a web site, Session Fixation provides a much wider window of opportunity. The active part of the attack takes place before a user logs in.</desc>
	<solution>Invalidate any existing session identifiers prior to authorizing a new user session

For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.</solution>
	<reference>http://projects.webappsec.org/Session-Fixation</reference>
	<reference>http://cwe.mitre.org/data/definitions/384.html</reference>
</vuln_item_wasc_37>

<vuln_items>wasc_38</vuln_items>
<vuln_item_wasc_38>
	<alert>URL Redirector Abuse</alert>
	<desc>URL redirectors represent common functionality employed by web sites to forward an incoming request to an alternate resource. This can be done for a variety of reasons and is often done to allow resources to be moved within the directory structure and to avoid breaking functionality for users that request the resource at its previous location. URL redirectors may also be used to implement load balancing, leveraging abbreviated URLs or recording outgoing links. It is this last implementation which is often used in phishing attacks as described in the example below. URL redirectors do not necessarily represent a direct security vulnerability but can be abused by attackers trying to social engineer victims into believing that they are navigating to a site other than the true destination.</desc>
	<solution>Hunahunaa nga ang tanan nga input kay malisyoso. Mogamit ug "dawata ang maayo nga nahibal-an" sa pagsulod sa pagbalido na estratehiya i.e., gamita ang usa ka whitelist sa mga madawat nga mga input nga estrikto nga subay sa mga paghingalan. Isalikway ang bisan unsang pagsulod nga dili hugot subay sa mga paghingalan, o na nag-usab kini sa bisag unsa nga gibuhat. Ayaw pagsalig lamang sa pagpangita sa mga malisyoso o sayop nga mga pagpasulod (pan., ayaw pagsalig sa blacklist). Bisan pa niini, ang mga blacklist kay mahimong mapuslanon para sa pagmatikod sa potensyal na mga atake o pagtino sa mga gipangsulod kay perteng pagkasayopa na sila nagkinahanglan nga isalikway dayon.

Sa paghimo sa pagpasulod na pagbalido, hunahunaa ang tanan nga kalabutan sa mga kabtangan, naglakip na sa gitas-on, tipo sa pagpasulod, ang bug-os nga lugway sa gipangdawat nga mga bili, nawala o sobra nga mga pagsulod, syntax, pagkamakanunayon sa tibuuk nga mga natad, ug pagpahiuyon sa mga lagda sa negosyo. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as "red" or "blue."

Use a whitelist of approved URLs or domains to be used for redirection.

Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving your site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems when generating the disclaimer page.

When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

For example, ID 1 could map to "/login.asp" and ID 2 could map to "http://www.example.com/". Mga butang sama sa ESAPI AccessReferenceMap kay naghatag niini nga kapasidad.

Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Hinumdomi kana nga mga gipangsulod kay mahimong makaangkon ug dili diretso pinaagi sa API nga mga tawag.

Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.</solution>
	<reference>http://projects.webappsec.org/URL-Redirector-Abuse</reference>
	<reference>http://cwe.mitre.org/data/definitions/601.html</reference>
</vuln_item_wasc_38>

<vuln_items>wasc_39</vuln_items>
<vuln_item_wasc_39>
	<alert>XPath Injection</alert>
	<desc>XPath Injection is an attack technique used to exploit applications that construct XPath (XML Path Language) queries from user-supplied input to query or navigate XML documents. It can be used directly by an application to query an XML document, as part of a larger operation such as applying an XSLT transformation to an XML document, or applying an XQuery to an XML document. The syntax of XPath bears some resemblance to an SQL query, and indeed, it is possible to form SQL-like queries on an XML document using XPath.

If an application uses run-time XPath query construction, embedding unsafe user input into the query, it may be possible for the attacker to inject data into the query such that the newly formed query will be parsed in a way differing from the programmer's intention.</desc>
	<solution>Use parameterized XPath queries (e.g. using XQuery). This will help ensure separation between data plane and control plane.

Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XPath queries is safe in that context.</solution>
	<reference>http://projects.webappsec.org/XPath-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/643.html</reference>
</vuln_item_wasc_39>

<vuln_items>wasc_40</vuln_items>
<vuln_item_wasc_40>
	<alert>Insufficient Process Validation</alert>
	<desc>Insufficient Process Validation occurs when a web application fails to prevent an attacker from circumventing the intended flow or business logic of the application. When seen in the real world, insufficient process validation has resulted in ineffective access controls and monetary loss.

There are two main types of processes that require validation: flow control and business logic.

"Flow control" refers to multi-step processes that require each step to be performed in a specific order by the user. When an attacker performs the step incorrectly or out of order, the access controls may be bypassed and an application integrity error may occur. Examples of multi-step processes include wire transfer, password recovery, purchase checkout, and account sign-up.

"Business logic" refers to the context in which a process will execute as governed by the business requirements. Exploiting a business logic weakness requires knowledge of the business; if no knowledge is needed to exploit it, then most likely it isn't a business logic flaw. Due to this, typical security measures such as scans and code review will not find this class of weakness. One approach to testing is offered by OWASP in their Testing Guide.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insufficient-Process-Validation</reference>
	<reference></reference>
</vuln_item_wasc_40>

<vuln_items>wasc_41</vuln_items>
<vuln_item_wasc_41>
	<alert>XML Attribute Blowup</alert>
	<desc>XML Attribute Blowup is a denial of service attack against XML parsers. The attacker provides a malicious XML document, which vulnerable XML parsers process in a very inefficient manner, leading to excessive CPU load. The essence of the attack is to include many attributes in the same XML node. Vulnerable XML parsers manage the attributes in an inefficient manner (e.g. in a data container for which insertion of a new attribute has O(n) runtime), resulting in a non-linear (in this example, quadratic, i.e. O(n2)) overall runtime, leading to a denial of service condition via CPU exhaustion.</desc>
	<solution>Design throttling mechanisms into the system architecture. Ang labing maayong proteksyon mao ang paglimit sa kantidad sa mga kapanguhaan nga ang dili awtorisado nga tiggamit kay makahimo ug gastohonon. Ang usa ka kusog nga pagkatinuod ug modelo sa access kontrol kay makatabang pagpugong sa mga pag-atake gikan sa pag-usab sa una nga dapit. Ang login na aplikasyon kay kinahanglan panalipdan batok sa mga atake sa DoS nga kutob sa iyang mahimo. Paglimitar sa database access, nga tingali pinaagi sa pag-cache nga resulta, kay makatabang na mapakunhod ang mga gipanggasto nga kapanguhaan. Sa dugang pa nga limit sa potensyal para sa atake nga DoS, hunahunaa ang pagsubay sa gidaghanon sa mga hangyo nga nadawat gikan sa mga tiggamit ug pagbabag sa mga hangyo nga labaw sa usa ka gihan-ay nga sukaranan nga rate.

Mitigation of resource exhaustion attacks requires that the target system either:
 * recognizes the attack and denies that user further access for a given amount of time, or
 * uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed. 

Ang una sa mga solusyon niini kay ang isyu sa iyang kaugalingon nga bisan pa, tungod kay kini motugot sa mga tig-atake na mapugan ang paggamit sa sistema nga pinaagi sa partikular na balidong tggamit. Kung ang tig-atake kay nagapakaaron-ingnon na usa ka balido nga tiggamit, kay mahimo niya na mapugngan ang tiggamit sa pag-access sa server sa pangutana.

Sa ikaduha nga solusyon kay yano nga pagkalisod aron sa epektibo nga institute -- ug bisan pa nga husto ang paghimo, kini wala maghatag ug usa ka bug-os nga solusyon. Kini yano gihimo sa tig-atake nga nagkinahanglan ug mga kapanguhaan sa bahin sa tig-atake.

Siguroha nga ang mga protocol kay adunay mga limitasyon sa gibutang ibabaw kanila.

Ensure that all failures in resource allocation place the system into a safe posture.</solution>
	<reference>http://projects.webappsec.org/XML-Attribute-Blowup</reference>
	<reference>http://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_41>

<vuln_items>wasc_42</vuln_items>
<vuln_item_wasc_42>
	<alert>Abuse of Functionality</alert>
	<desc>Abuse of Functionality is an attack technique that uses a web site's own features and functionality to attack itself or others. Abuse of Functionality can be described as the abuse of an application's intended functionality to perform an undesirable outcome. These attacks have varied results such as consuming resources, circumventing access controls, or leaking information. The potential and level of abuse will vary from web site to web site and application to application. Abuse of functionality attacks are often a combination of other attack types and/or utilize other attack vectors.</desc>
	<solution>Always utilize APIs in the specified manner.</solution>
	<reference>http://projects.webappsec.org/Abuse-of-Functionality</reference>
	<reference>http://cwe.mitre.org/data/definitions/227.html</reference>
</vuln_item_wasc_42>

<vuln_items>wasc_43</vuln_items>
<vuln_item_wasc_43>
	<alert>XML External Entities</alert>
	<desc>This technique takes advantage of a feature of XML to build documents dynamically at the time of processing. An XML message can either provide data explicitly or by pointing to an URI where the data exists. In the attack technique, external entities may replace the entity value with malicious data, alternate referrals or may compromise the security of the data the server/XML application has access to.
	Attackers may also use External Entities to have the web services server download malicious code or content to the server for use in secondary or follow on attacks.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/XML-External-Entities</reference>
	<reference></reference>
</vuln_item_wasc_43>

<vuln_items>wasc_44</vuln_items>
<vuln_item_wasc_44>
	<alert>XML Entity Expansion</alert>
	<desc>The XML Entity expansion attack, exploits a capability in XML DTDs that allows the creation of custom macros, called entities, that can be used throughout a document. By recursively defining a set of custom entities at the top of a document, an attacker can overwhelm parsers that attempt to completely resolve the entities by forcing them to iterate almost indefinitely on these recursive definitions.

The malicious XML message is used to force recursive entity expansion (or other repeated processing) that completely uses up available server resources.</desc>
	<solution>If possible, prohibit the use of DTDs or use an XML parser that limits the expansion of recursive DTD entities.

Before parsing XML files with associated DTDs, scan for recursive entity declarations and do not continue parsing potentially explosive content.</solution>
	<reference>http://projects.webappsec.org/XML-Entity-Expansion</reference>
	<reference>http://cwe.mitre.org/data/definitions/776.html</reference>
</vuln_item_wasc_44>

<vuln_items>wasc_45</vuln_items>
<vuln_item_wasc_45>
	<alert>Fingerprinting</alert>
	<desc>The most common methodology for attackers is to first footprint the target's web presence and enumerate as much information as possible. With this information, the attacker may develop an accurate attack scenario, which will effectively exploit a vulnerability in the software type/version being utilized by the target host.

Multi-tier fingerprinting is similar to its predecessor, TCP/IP Fingerprinting (with a scanner such as Nmap) except that it is focused on the Application Layer of the OSI model instead of the Transport Layer. The theory behind this fingerprinting is to create an accurate profile of the target's platform, web application software technology, backend database version, configurations and possibly even their network architecture/topology.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Fingerprinting</reference>
	<reference></reference>
</vuln_item_wasc_45>

<vuln_items>wasc_46</vuln_items>
<vuln_item_wasc_46>
	<alert>XQuery Injection</alert>
	<desc>XQuery Injection is a variant of the classic SQL injection attack against the XML XQuery Language. XQuery Injection uses improperly validated data that is passed to XQuery commands. This inturn will execute commands on behalf of the attacker that the XQuery routines have access to. XQuery injection can be used to enumerate elements on the victim's environment, inject commands to the local host, or execute queries to remote files and data sources. Like SQL injection attacks, the attacker tunnels through the application entry point to target the resource access layer.</desc>
	<solution>Use parameterized queries. This will help ensure separation between data plane and control plane.

Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XQL queries is safe in that context.</solution>
	<reference>http://projects.webappsec.org/XQuery-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/652.html</reference>
</vuln_item_wasc_46>

<vuln_items>wasc_47</vuln_items>
<vuln_item_wasc_47>
	<alert>Insufficient Session Expiration</alert>
	<desc>Insufficient Session Expiration occurs when a Web application permits an attacker to reuse old session credentials or session IDs for authorization. Insufficient Session Expiration increases a Web site's exposure to attacks that steal or reuse user's session identifiers.

Since HTTP is a stateless protocol, Web sites commonly use cookies to store session IDs that uniquely identify a user from request to request. Consequently, each session ID's confidentiality must be maintained in order to prevent multiple users from accessing the same account. A stolen session ID can be used to view another user's account or perform a fraudulent transaction.

Session expiration is comprised of two timeout types: inactivity and absolute. An absolute timeout is defined by the total amount of time a session can be valid without re-authentication and an inactivity timeout is the amount of idle time allowed before the session is invalidated. The lack of proper session expiration may increase the likelihood of success of certain attacks. A long expiration time increases an attacker's chance of successfully guessing a valid session ID. The longer the expiration time, the more concurrent open sessions will exist at any given time. The larger the pool of sessions, the more likely it will be for an attacker to guess one at random. Although a short session inactivity timeout does not help if a token is immediately used, the short timeout helps to insure that the token is harder to capture while it is still valid.

A Web application should invalidate a session after a predefined idle time has passed (a timeout) and provide the user the means to invalidate their own session, i.e. logout; this helps to keep the lifespan of a session ID as short as possible and is necessary in a shared computing environment where more than one person has unrestricted physical access to a computer. The logout function should be prominently visible to the user, explicitly invalidate a user’s session and disallow reuse of the session token.</desc>
	<solution>Set sessions/credentials expiration date.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Session-Expiration</reference>
	<reference>http://cwe.mitre.org/data/definitions/613.html</reference>
</vuln_item_wasc_47>

<vuln_items>wasc_48</vuln_items>
<vuln_item_wasc_48>
	<alert>Insecure Indexing</alert>
	<desc>Insecure Indexing is a threat to the data confidentiality of the web-site. Indexing web-site contents via a process that has access to files which are not supposed to be publicly accessible has the potential of leaking information about the existence of such files, and about their content. In the process of indexing, such information is collected and stored by the indexing process, which can later be retrieved (albeit not trivially) by a determined attacker, typically through a series of queries to the search engine. The attacker does not thwart the security model of the search engine. As such, this attack is subtle and very hard to detect and to foil - it’s not easy to distinguish the attacker’s queries from a legitimate user’s queries.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insecure-Indexing</reference>
	<reference></reference>
</vuln_item_wasc_48>

<vuln_items>wasc_49</vuln_items>
<vuln_item_wasc_49>
	<alert>Insufficient Password Recovery</alert>
	<desc>Insufficient Password Recovery is when a web site permits an attacker to illegally obtain, change or recover another user's password. Conventional web site authentication methods require users to select and remember a password or passphrase. The user should be the only person that knows the password and it must be remembered precisely. As time passes, a user's ability to remember a password fades. The matter is further complicated when the average user visits 20 sites requiring them to supply a password.  (RSA Survey: http://news.bbc.co.uk/1/hi/technology/3639679.stm) Thus, password recovery is an important part in servicing online users.

Examples of automated password recovery processes include requiring the user to answer a "secret question" defined as part of the user registration process. This question can either be selected from a list of canned questions or supplied by the user. Another mechanism in use is having the user provide a "hint" during registration that will help the user remember his password. Other mechanisms require the user to provide several pieces of personal data such as their social security number, home address, zip code etc. to validate their identity. After the user has proven who they are, the recovery system will display or e-mail them a new password.

A web site is considered to have Insufficient Password Recovery when an attacker is able to foil the recovery mechanism being used. This happens when the information required to validate a user's identity for recovery is either easily guessed or can be circumvented. Password recovery systems may be compromised through the use of brute force attacks, inherent system weaknesses, or easily guessed secret questions.</desc>
	<solution>Make sure that all input supplied by the user to the password recovery mechanism is thoroughly filtered and validated

Do not use standard weak security questions and use several security questions.

Make sure that there is throttling on the number of incorrect answers to a security question. Disable the password recovery functionality after a certain (small) number of incorrect guesses.

Require that the user properly answers the security question prior to resetting their password and sending the new password to the e-mail address of record.

Never allow the user to control what e-mail address the new password will be sent to in the password recovery mechanism.

Assign a new temporary password rather than revealing the original password.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Password-Recovery</reference>
	<reference>http://cwe.mitre.org/data/definitions/640.html</reference>
</vuln_item_wasc_49>

</vulnerabilities>